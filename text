1. Johdatus relaatiotietokantoihin
1. Tietokanta
2. Tietokannanhallintajärjestelmä
3. Tietomallit
4. SQL-kyselykieli

 
1.1 Tietokanta
Tietokanta on jotakin tarvetta varten luotu kokoelma tietoa. Se on suunnitelmallisesti luotu ja se palvelee jotakin tarkoitusta. Pelkkä satunnainen kasa tietoa ei siten vielä ole tietokanta. Esimerkkejä tietokannoista voisivat olla reseptikokoelma, osoitemuistio tai yhdistyksen jäsenrekisteri.
Teoreettisemmin ajatellen on tietokannalla tavallisesti ainakin seuraavat ominaisuudet:
• Tietokantaan tallennettu tieto on loogisesti yhteenkuuluvaa. Siellä ei ole tarpeetonta tai satunnaista tietoa.
Tämä tarkoittaa, että on tarkkaan määritetty mitä tietoja tietokannasta voidaan saada tai sinne viedä. Tietoa, joka ei ole tarpeellista juuri sitä käyttöä varten johon tietokanta on luotu, ei sieltä löydy.
• Tietokannan käyttäjät tunnetaan
		○ Koska tietokannan olemassaololle on selkeä tarkoitus ja tiedetään tarkkaan mitä tietoa sieltä on saatavissa, on väistämättä selvää, että myös käyttäjät joita tietokanta palvelee on tunnettava. Yliopiston kirjaston tietokantajärjestelmässä tämä tarkoittaa, että käyttäjä ymmärretään yliopiston henkilökuntaan tai opiskelijoihin kuuluvana. Tämän perusteella on päätelty, mitä tarpeita näillä käyttäjillä on tietokantaan nähden.
• Tietokannassa oleva tieto ja sen esitysmuoto mallintavat tiettyä rajoitettua osaa reaalimaailmasta. Tietokanta ei kuitenkaan ole yhden-suhde-yhteen tarkka esitys ongelmasta johon se vastaa.
Tähän ominaisuuteen palaamme tietokantojen suunnittelun ja itse relaatiomallin yhteydessä. Tietokannan voidaan ajatella mallintavan niitä asioita, joihin siinä olevat tiedot liittyvät. Kirjaston tietokannasta löytyy ainakin tietoja kirjoista ja niiden saatavuudesta. Se mallintaa tiettyä osaa itse kirjaston toiminnasta: Tietokannassa on kirjoja, joilla on samanlaisia ominaisuuksia kuin "oikeillakin" kirjaston kirjoilla, mutta näistä ominaisuuksista (sivumäärä, painovuosi, ISBN jne.) esitetään vain tarpeellinen osa. Kun kirjastosta lainataan kirjoja, tietokannassakin tapahtuu vastaavia päivityksiä. Tietokanta siis mallintaa kirjastoa, mutta vain rajoitetusti.
• Tiedon esitysmuoto noudattaa jotakin tietomallia.
		○ Tietokanta ei esitä tietoja miten sattuu, vaan hyvin systemaattisesti. Tietomalli määrittää, miten tämä tapahtuu. Se myös asettaa rajoitukset, mitä kaikkea tietokannassa voidaan esittää. Tässä yhteydessä puhutaan usein loogisesta tai semanttisesta tiedosta raa'an datan ohessa.


1.2 Tietokannanhallintajärjestelmä
Tietokanta voi olla suuri tai pieni, yksinkertainen tai monimutkainen. Lisäksi tietokanta sisältää tavallisesti paljon muutakin kuin pelkkää dataa. Yleensä tietokannan varsinaiseen käyttöön tarvitaan erillinen ohjelmistokomponentti, eikä pelkkä tietokanta suoraan palvele käyttäjiä. Tämä ohjelmisto tunnetaan tietokannanhallintajärjestelmänä (TKHJ.) Käyttäjät voivat sen avulla tehdä kyselyjä tietokantaan, tai lisätä, poistaa ja muokata tietokannassa olevaa tietoa. Käyttäjä voi TKHJ:n kannalta olla yksittäinen ihminen tai jokin asiakasohjelma, jolta se saa SQL lauseiksi muotoiltuja toimintaohjeita - eli mitä asiakas haluaa TKHJ:n tietokannalle tekevän. Toimintoja voisivat olla esimerkiksi: "Listaa heinäkuun kokonaismyynti tuotteen X osalta," tai "Päivitä tilauksen X tunnuskoodiksi 123225." Tällainen toiminto muotoillaan SQL-kieliseksi lausekkeeksi, jota TKHJ ymmärtää, ja jonka se voi siten toteuttaa tietokannalle.
TKHJ toimii täten operaattorina käyttäjien ja tietokannan välissä. Käyttäjät ohjaavat TKHJ:tä toiminto- ja kyselykielten avulla; relaatiotietokannan yhteydessä tällaisista kielistä SQL-kieli on ainakin tuettu. Tyypillinen loppukäyttäjä ei useinkaan itse syötä varsinaisia SQL lauseita, vaan ne on luotu hänelle valmiiksi, tai käytössä oleva ohjelmisto voi luoda niitä tarpeen mukaan.
Tietokannahallintajärjestelmä vastaa monista muistakin tehtävistä. Tärkeimpiä ovat:
• TKHJ:stä riippuu tietomalli jota tietokanta noudattaa. Relaatiotietokantaa luotaessa ja käytettäessä on siksi käytettävä TKHJ:tä joka tulee relaatiomallia.
• Tietokannan ylläpitoon liittyvät toimet suoritetaan lähes aina TKHJ:n avulla. Samoin tietoturva, tiedon varmistus- ja palaustoimet, ja transaktioiden varmistus, ovat TKHJ:n vastuulla. Miten ja mitä toimintoja tarkalleen tuetaan, riippuu täysin valitusta tietokannanhallintajärjestelmästä.
• Tietokannanhallintajärjestelmä vastaa myös käyttäjien ja käyttöoikeuksien hallinnasta: Kuka saa tietokantaa käyttää ja miten. TKHJ:n kontille voi kuulua vielä paljon muutakin. TKHJ:tä on hyvin eri laajuisia ja erilaisiin käyttötarpeisiin.
Voidaan summata seuraavasti: Tietokanta noudattaa tietomallia, jonka mukaista tietokannanhallintajärjestelmää käytetään tietokannan operoimiseen, esim. SQL-kielen avulla. Usein TKHJ:n on oltava samanlainen kuin millä tietokanta on luotu. TKHJ:lle kerrotaan SQL-kielen avulla mitä tietokannasta halutaan, ja TKHJ - suoritettuaan tehtävän tietokannalle - palauttaa käyttäjälle esimerkiksi tulosteen halutuista tiedoista tai ilmoituksen, että haluttu toiminto onnistui ja tietokanta on päivitetty. Alla on kuva tästä toimintaperiaatteesta. Tietokantajärjestelmään kuuluu toki muutakin, esim. tallennusjärjestelmiä, tietoverkkoja yms. jota ei tässä yhteydessä käsitellä laajemmin.
 



1.3 Tietomallit
Käsittelemme tietomalleja tässä lyhyesti siten kuin ne ymmärretään tietokantojen yhteydessä.
Tietomalli (data model) määrittää tietokantaan tallennettavan tiedon loogisen rakenteen ja esitysmuodon. Samaa tietomallia noudattavat tietokannat näkyvät käyttäjälle samanlaisina tiedon semantiikan suhteen, mutta kyseiset tietokannat saattavat tallentaa dataa fyysisellä tasolla aivan eri tavoin. Tämä tarkoittaa, että tietomalli ei määritä miten tietokannan data tallennetaan levylle tiedostoiksi, tai miten TKHJ löytää haluamansa tietoalkion tai järjestää ne hakuja varten hakemistoihin ja tiedostoihin. Tietomalli määrittää, miten käyttäjä näkee nämä tiedot tietokantaa operoidessaan, ja mitä hän voi niillä tehdä.
Relaatiomallin mukaiset tietokannat noudattavat relaatiomallia, eivätkä ne voi perustua mihinkään muuhun tietomalliin, eikä puhtaassa relaatiokannassa voi esiintyä piirteitä muista tietomalleista. Nykyisin on tosin saatavissa myös laajennettuja ns. hybridi malleja, joissa relaatiotietokantaan on tuotu piirteitä oliotietokannoista.
 

1.3.1 TIETOMALLIT JA RELAATIOMALLI
Relaatiomallissa tiedon tallennus ja esitys perustuu relaatioihin (= taulu, taulukko) sekä relaatioiden välillä vallitseviin loogisiin yhteyksiin. Relaatiomalli käydään läpi seuraavassa luvussa. Esimerkki kahdesta relaatiosta nähdään sivun alaosassa.
Tietomalli määrittää säännöt miten yksittäinen tietoalkio voidaan esittää sekä miten toisiinsa yhteenkuuluvaa tietoa voidaan tämän perusteella käsitellä. Siten se asettaa rajat kuinka suuri määrä semanttista eli loogista tietoa voidaan tallentaa puhtaan datan ohessa. Esimerkiksi puhdasta dataa voivat olla kirjastotietokannan niteiden nimet. Tietomallista riippuu, miten tuodaan esiin yhteys tietyn niteen nimen ja niteeseen liittyvän tekijän tai kirjan välillä (Olettaen, että kirjasta on olemassa useita niteitä). Tietomallien kyky esittää tällaista semanttista tietoa vaihtelee, ja pääasiassa tämä kyky on ollut sitä parempi mitä uudemmasta tietomallista on ollut kyse.
Relaatiomalli voi käsitellä edellä kuvatun kaltaista yksinkertaista semantiikka helposti. Se osaa tehokkaasti yhdistää esimerkiksi niteen ja siihen liittyvän kirjan tai kirjailijan toisiinsa. Edelleen kirjaan liittyvään kirjailijaan voi liittyä uusia tietoja niin, että syntyy ketju toisiinsa loogisesti liittyviä tietoalkioita: Kirjailija "Meikäläinen Matti" liittyy kirjoihin tuo, tuo, ja vielä tuo. Näistä viimeiseen liitty myös toinen kirjailija. Jokaisella kirjalla on kuitenkin eri kustantaja, jne. Seuraamalla tällaisia yhteenkuuluvan tiedon polkuja voidaan selvittää, mille kustantajille kirjailija Meikäläinen Matti on julkaissut. Tällainen looginen yhteenliittäminen on relaatiomallille ominaista.
Relaatiomallin yhteydessä palataan tarkemmin mallin toimintatapaan. Keskeisessä roolissa ovat taulut eli relaatiot, joiden kautta käyttäjä näkee kaiken tietokannassa olevan tiedon. Tällaisissa tauluissa olevien tietoalkioiden välille syntyvät edellä mainitut loogiset "tämä liittyy tähän" ketjut.
Alla on annettu alustavana esimerkkinä kaksi relaatiota, jotka voisivat olla laajemmasta tietokannasta.


1.3.2 RELAATIOT, ESIMERKKI
Kaksi taulua, eli relaatiota: Teos ja Nide. Yksittäinen nide edustaa jotakin teosta/kirjaa. Nähdään kunkin yksittäisen niteen hyllypaikka ja saatavuustiedot, sekä painos. Esim. teoksesta jonka tunnus on 1, on kaksi nidettä.


Teos
TeosID
Nimi
KustantajaID
ISBN
1
Tietokantojen perusteet
2
9-123456-123456
2
Tietokantojen jatkokurssi
17
5-212561-123456
3
Pieni SQL opas
2
7-654321-123123
4
Tiedonhallintajärjestelmät
102
1-121212-998812
Nide
NideID
TeosID
Sijainti
Saatavuus
Painos
1
1
E90
Lainassa
2
2
1
E90
Hyllyssä
1
3
2
E91
Hyllyssä
8
4
2
K102
Ei lainata
8
5
3
K102
Ei lainata
1
6
4
E89
Hyllyssä
3


1.3.3 TIETOMALLIEN HISTORIAA
Relaatiomallin määritelmän syntyessä 1970-luvulla oli markkinoilla jo kaksi hallitsevaa tietomallia, hierarkinen- ja verkkomalli. Kumpikin näistä perustui samanlaisiin tietueisiin kuin mitä nähdään relaatiomallin tauluissa. Ne ovat kuitenkin enemmän juuri tietuekeskeisiä siinä missä relaatiomalli keskittyy tauluihin eli relaatioihin. Relaatiomalli tarjoaa edeltäjiään korkeamman semanttisen tason, eikä mallin käyttäjä ole niinkään kiinnostunut tiedon käsittelystä yksittäisten tietueiden tasolla, toisin kuin näissä aiemmissa malleissa. Relaatiomalli kykenee näin luontevammin mallintamaan reaalimaailmaa ja tietojen välillä vallitsevia loogisia yhteyksiä. Lisäksi relaatiomalli tarjoaa tarkat määritykset tiedon eheydestä ja siihen liittyvistä operaatioista. Aiemmissa malleissa mallin kuvaukset ja määritykset syntyivät lähinnä käytön myötä, kun taas relaatiomallille oli jo ennen ensimmäisiä sovelluksia luotu tarkka, matemaattinen pohja.
Relaatiomallin mukaiset tietokannat nousivat hallitsevaan rooliin 80-luvulla, ja ovat sitä edelleen. Tietokantamaailmassa kehitys jatkui erityisesti 90-luvulla nousseiden uusien tietokantamallien myötä. Ohjelmistoteollisuudessa syntynyt oliomalli tuotiin myös tietokantamaailmaan: Motivaationa uudelle tietomallille oli oliomallinnuksen kyky esittää suurta määrää semanttista tietoa luontevasti, ja tämä on erityisesti tarpeen tietokannoissa. Relaatiomallin rajoitteet on koettu liian suuriksi tietyissä erityistapauksissa, ja oliomallista on povattu relaatiomallin syrjäyttäjää uutena tietokantastandardina. Toistaiseksi relaatiotietokannat ovat pitäneet pintansa.
Oliomallin myötä on myös tuotu eräänlaisia hybridejä, eli relaatio-olio sekamalleja. Motivaationa on ollut lieventää relaatiomallin ja oliomallin välistä kuilua -- olemassa olevien järjestelmien ja asiantuntemuksen muuntaminen uuteen tietomalliin ei onnistu noin vain, ja siirtymää voisi helpottaa jos relaatiomalliin voitaisiin tuoda oliomallin hyviä piirteitä, mutta niin että relaatiomallista ei tarvitsisi kokonaan luopua. Tällaisia malleja kutsutaan olio-relaatio malleiksi (OR-mallit.)
Toisaalta oliotietokantojen rinnalle ovat nousseet myös uusimmat "internet ajan" teknologiat, kuten XML tiedonkuvauskieleen perustuvat ratkaisut tai Java teknologiaan pohjaavat tietokannat, jotka pyrkivät vastaamaan web teknologioiden kehityksen myötä syntyneisiin tarpeisiin. Relaatiotietokannat ovat kuitenkin säilyneet edelleen hallitsevana tietokantamallina.

1.4 SQL-kyselykieli
SQL-kieli liittyy läheisesti relaatiotietokantoihin. Muissa tietokannoissa voidaan toisinaan myös käyttää SQL:ään perustuvia tai sitä laajentavia kyselykieliä.
SQL, Structured Query Language, on erityisesti relaatiotietokantoja varten kehitetty kyselykieli. Kaikki relaatiotietokannat ymmärtävät sitä, ja monesti puhutaankin myös SQL-kannoista, kun viitataan relaatiomallin mukaisiin tietokantoihin.
Tietokannanhallintajärjestelmän yhteydessä kerrottiin, että käyttäjät tarvitsevat standardoidun tavan kertoa tietokannanhallintajärjestelmälle mitä tehtäviä he tahtovat sen tietokannalla suorittavan. TKHJ:hän toimi käyttäjän ja tietokannan välissä eräänlaisena operaattorina, joka ottaa vastaan käyttäjän sille antamat tehtävät ja sitten huolehtii niiden toteuttamisesta tietokannassa. SQL-kieli on kehitetty juuri käyttäjän ja TKHJ:n väliseen yhteydenpitoon: Se on standardoitu tapa antaa tehtäviä mille tahansa relaatiotietokannalle.
SQL:ää kutsutaan kyselykieleksi, sillä yleisimmät toimet mitä käyttäjä tietokannalta pyytää, ovat juuri tietokannassa olevien tietojen kyselyjä. Esimerkiksi: "Onko nide XYZ lainassa?" "Mitä teoksia löytyy asiasanalla 'tietojenkäsittely'", "Kenellä on lainassa nide XYZ?" jne. TKHJ tulkitsee SQL-kielisen pyynnön, hakee tiedot kannasta, ja esittää ne käyttäjälle SQL-lauseessa määritetyllä tavalla; vaikkapa tietyn ominaisuuden mukaan järjestettynä listana.
SQL-kielellä voidaan suorittaa paitsi kyselyjä tietokantaan, myös monia muita TKHJ:n toimia. Näitä ovat uuden tietokannan luominen, tietokannan taulujen määrittäminen, taulujen ominaisuuksien muuttaminen, jne. Myös kaikki tiedon päivittämiseen, lisäämiseen ja poistamiseen liittyvät toimet voidaan suorittaa SQL:n avulla. Relaatiomallin kaikki ominaisuudet ovat käytettävissä SQL-kielestä käsin.
Esimerkki SQL-lauseesta, joka suorittaa kyselyn tietokantaan:
	
	SELECT *
	  FROM Lainaus
	  WHERE Pvm < '2007-08-01';


SQL-kielen tunteminen antaa mahdollisuuden luoda, ylläpitää ja käyttää relaatiotietokantoja. Myös ohjelmat joissa varsinainen SQL on piilotettuna käyttäjältä pohjaavat SQL-kielisiin kyselyihin. Tällöin SQL-kielen tunteva henkilö on suunnitellut kyselyt valmiiksi, tai ohjelma osaa rakentaa niitä käyttäjän pyynnöstä.
SQL-kieli on standardoitu, ja standardista on vuosien varrella tullut uusia versioita. Myös tietokantatuotteita myyvät valmistajat ovat tehneet omia SQL-laajennuksiaan standardin päälle, jotka eivät välttämättä ole yhteensopivia jonkin toisen valmistajan relaatiotietokannan kanssa. Tällä kurssilla käsitellään vain standardin mukaista SQL:ää, jota kaikkien SQL:ää tukevien TKHJ:en tulisi ymmärtää yhtäläisesti.
Seuraavassa luvussa paneudutaan relaatiomalliin ja SQL-kieleen palataan hieman tuonnempana.

2. Relaatiomallin perusteita
5. Relaatio
6. Avainattribuutit: Pääavain
7. Avainattribuutit: Tiedon yhdistäminen
8. Avainattribuutit: Yhdistetty pääavain
9. Relaatiomalli ja tiedon yksikäsitteisyys
10. Keskeisiä termejä suomeksi ja englanniksi

 
2.1 Relaatio
Relaatiomallissa tietojen tallentamiseen käytettävä perusrakenne on relaatio, josta myös mallin nimi on johdettu. Relaatiota sanotaan usein myös tauluksi tai taulukoksi. Relaatio käsitteenä erottaa relaatiomallin aiemmista, pelkästään tietuepohjaisista tietomalleista. Toisaalta myös relaatiomalli hyödyntää tietueita -- yksittäisessä taulussa olevat tiedot esitetään tietueina.
 

2.1.1 YKSITTÄINEN RELAATIO ELI TAULU
Jotta voidaan tarkastella mistä ja miten relaatiot koostuvat, ja miten tieto relaatiomallissa esitetään, tarkastellaan aluksi esimerkkinä yksittäistä relaatiota. Yksittäinen taulu on relaatiotietokannan perusyksikkö, jonka kautta tietoa esitetään. Alempana on esitetty taulun eri rakenneosien nimet.
Relaatio voisi olla osa laajempaa tietokantaa, jossa on tietoa mm. yrityksen työntekijöistä. Laajempi kokonaisuus, joka koostuu useista tauluista, esitellään hiukan alempana.
Esimerkki relaatiosta: Taulu Työntekijä
 

TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
 
Taulussa on esitetty tietoja kuvitellun kansainvälisen yrityksen työntekijöistä. Todellisessa tietokannassa taulu olisi toki paljon suurempi. Kullekin työntekijälle on annettu yksilöivä tunnusluku, ID numero, ja tämän ohella on haluttu tallentaa työntekijän nimi, puhelinnumero ja kotiosoite. Toimipaikka ID on koodi työntekijän tämänhetkisestä toimipisteestä, ja se on annettu toimipaikoista tietoa sisältävään tauluun viittaavana koodina. (Tämä taulu nähdään hiukan myöhemmin) Esimerkiksi LPR tarkoittaa Lappeenrannan toimipaikkaa, ja Hki-1 toista Helsingin toimitilaa. Taulu on osa laajempaa kokonaisuutta, ja tämä näkyy juuri viittauksina toisen taulun sisältämiin tietoihin.
Yksittäisen työntekijän tiedot on esitetty aina yhdellä rivillä. Tämä pätee aina relaatiomallin tauluihin: Riippumatta mitä tietoja taulu sisältää, muodostaa yksittäinen vaakarivi aina yhden tieuteen eli tietokokonaisuuden. Tietue ei koskaan voi olla kuin yhden rivin laajuinen.
 

2.1.2 TAULUN RAKENNE JA RAKENNEOSIEN NIMET
Taulun ylin rivi on merkitty taustavärillä ja sen fontti on lihavoitu. Tällä ensimmäisellä rivillä esitetään taulun attribuutit. Kukin attribuutti määrittää sen alla olevan sarakkeen ominaisuudet. Täten attribuutin Nimi alla olevaan sarakkeeseen on jokaiselle riville eli tietueelle annettu vain ja ainoastaan Nimi tyyppiä oleva tieto. kts. kuva 1. Attribuutilla on siksi aina yksikäsitteinen tietotyyppi, joka kertoo, minkälaisia arvoja tämä attribuutti edustaa. Tietotyyppejä voivat olla esimerkiksi kokonaisluku, merkkijono, päivämäärä, jne. Attribuutilla on myös arvoalue, joka määrittää, mitä tietotyypin mukaisia arvoja se voi sisältää. Tarkemmin tästä ja attribuuttien sekä tietotyyppien ns. eheyssäännöistä on kerrottu luvuisa 9 ja 10. Yllä attribuutti Nimi lienee tyyppiä merkkijono, kun taas TyontekijaID on todennäköisesti kokonaisluku.
Taulun kukin rivi muodostaa yksittäisen tietueen. Rivit eli tietueet yhdessä muodostavat edelleen taulun tietosisällön. Attribuutit ovat osa taulun rakennetta, eivätkä sellaisenaan sisällä tietoa. Yllä oleva taulu koostuu siten seitsemästä tietueesta ja taulun rakenteeseen on määritetty viisi attribuuttia. Kullekin attribuutille on edelleen määritetty tietotyyppi. Yksittäinen rivi koostuu kentistä (soluista), joista jokainen sisältää jonkin yksittäisen tiedon, ja tämä tieto on aina tietysti jonkin attribuutin mukainen. Voidaan myös sanoa, että relaatiossa on yksi tietoalkio aina yhdessä solussa. Koska kentässä oleva tieto on tyypiltään kyseisen sarakkeen attribuutin mukaista, on Nimi-attribuutin alla olevissa soluissa oltava siten vain Nimi tyyppisiä tietoja.
Taulun rakenteeseen sisältyy vielä tiettyjä tarkennuksia, jotka ovat välttämättömiä useista tauluista koostuvan tietokannan luomiseksi. Näitä kutsutaan avainattribuuteiksi, ja niistä tärkeimpiä käydään läpi seuraavaksi. Samalla nähdään, miten relaatiotietokanta rakentuu, kun tauluja on useampia kuin yksi.
 
Kuva 1: Taulun rakenne ja eri osien nimet.



2.2 Avainattribuutit: Pääavain
Relaatiomalli edellyttää, että jokaisella tietokannan taululla tulee olla määritetty erityinen attribuutti, jonka nimi on pääavain. Pääavain liittyy sääntöön jonka mukaan taulussa sai olla vain yksi tietue per rivi, eli jokainen rivi on aina yksi ja vain ja ainoastaan yksi tietue.
 

2.2.1 PÄÄAVAIN YKSILÖI TAULUN TIETUEET
Mistä tietokanta tietää, mikä tietue sen on taulusta poimittava, kun pyydetään työntekijän, jonka  ID=3, tiedot? TKHJ tietenkin noutaa tietueen jonka TyöntekijaID attribuutin kohdalla on annettu arvo "3"; Alla olevassa tapauksessa siis Sillanpää Salla.
 
Taulu Työntekijä
 

TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
Tämä vaikuttaa varsin selvältä. Mutta jos TyöntekijaID attribuuttia ei olisi, ja taulussa olisi useampi saman niminen työntekijä, ei voitaisi tietää kehen heistä viitataan kun kyseisellä nimellä pyydetään noutamaan tietue. Siksi relaatiossa on aina oltava attribuutti, joka on erikseen määritetty pääavainattribuutiksi. Pääavain yksilöi jokaisen taulun tietueen niin, että kahdella tietueella ei koskaan voi olla samaa pääavainattribuutin arvoa. Yllä olevassa taulussa pääavaimeksi on valittu TyöntekijaID. Sen avulla on annettu jokaiselle tietueelle yksilöivä ID numero. Täten kahdella työntekijällä ei koskaan voi olla samaa TyontekijaID:tä, olivatpa heidän muut tietonsa millaisia hyvänsä. Jokainen tietue on näin aina yksilöllinen, eikä sitä voida sekoittaa vahingossa toiseen tietueeseen, kun tietokantaa operoidaan. Kaksi saman nimistä työntekijää eivät sekoitu toisiinsa.
Verrataan kahta alla olevaa taulua: Kummassakin on kaksi saman nimistä työntekijää.
 

TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
6	Sillanpää Salla	Lontoo	123 560123123	Bridge Road 53...
7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
 

Nimi	ToimipaikkaID 	PuhNumero	Kotiosoite
Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
LeBlanc Custou  	Hki-1	358 046-123123 	Hirvitie 10, 43850  
Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
Sillanpää Salla	Lontoo	123 560123123	Bridge Road 53...
Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
Alemmassa taulussa ei ole ylemmän TyöntekijaID-attribuuttia. Ylemmässä taulussa on selvää, että kyseinen attribuutti on luotu toimimaan taulun avaimena: kaksi samannimistäkin työntekijää voidaan näin yksilöidä. Alemmassa taulussa Nimi ei ole pääavain. Se ei voi olla, koska se ei yksilöi taulun tietueita -- kahdella tietueella kun jo nyt on sama arvo tälle attribuutille. Puhelinnumero tai Kotiosoite voisivat toimia pääavaimena, mutta vain jos ei ole mitenkään mahdollista kahden työntekijän saada samaa arvoa näille attribuuteille. Paras ratkaisu on siis yleensä luoda taululle pääavainattribuutti, mikäli sopivaa ei valmiiksi löydy. Tässä tapauksessa luodaan ylemmän taulun mukainen TyöntekijaID, -numero, -tunnus tms. jonka toistumattomuuteen ja siten yksilöllisyyteen jokaiselle tietueelle voidaan luottaa 100% varmasti.
Voidaan kysyä, miksi tällainen tarvitaan? Onhan selvää, että kaksi saman nimistä työntekijää, joilla on eri osoite ja puhelinnumero, ovat eri tietueita. Tämä voi olla selvää ihmiselle. (Tai sitten ei, jos kyseessä on virheellisesti syötetty tieto!) Relaatiotietokannassa taulu on kuitenkin järjestettävä jollakin keinoin, ja TKHJ:n on tiedettävä yksiselitteisesti mistä tietueesta on milloinkin kyse. Koska jokainen tietue on voitava erottaa muista, on oltava jokin tapa kertoa aina luotettavasti, mikä tietue mikäkin rivi on. Siksi tarvitaan pääavain. Yksinkertaistettuna voidaan sanoa, että tietokanta käsittelee taulun tietueet pääavainattribuutin perusteella.
Näin ollen alla olevassa taulussa on kaksi tietuetta. Tietueen ja pääavaimen määritelmistä seuraa, että ne ovat myös erilaisia. Jos nyt tietueille annettaisiin sama pääavainattribuutin arvo (esim "1"), tulisi niistä yksi ja sama tietue, ja toinen rivi poistettaisiin turhana. Tästä edelleen seuraa, että relaatiossa ei koskaan ole kahta identtistä tietuetta.
 

TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
2	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
 
 

2.2.2 PÄÄAVAIMEN VALINTA
Yllä esitetyn perusteella voisi päätellä, että kun on määritetty taulu joka sisältää halutut attribuutit tauluun tuleville tietueille, pitäisi sen jälkeen luoda aina erillinen pääavainattribuutti vain pääavainkäyttöä varten. Näin ei aina ole. Otetaan esimerkiksi taulu joka sisältää tietoja yliopiston opiskelijoista. Se voisi sisältää seuraavia attribuutteja:

    OpiskelijaNro
    Etunimi
    Sukunimi
    Laitos
    Koulutusohjelma
    jne... lista jatkuisi
Kun tiedetään, että jokainen yliopisto-opiskelija yksilöidään aina opiskelijanumeron perusteella, voidaan tämä attribuutti valita suoraan taulun pääavaimeksi, eikä ole tarvetta luoda erillistä pääavainattribuuttia. Kahdella opiskelijalla on aina eri opiskelijanumero, ja täten kahdelle tietueelle ei voi tulla samaa pääavainarvoa. Tällainen ratkaisu on aina suositeltavin, sillä näin vältytään ylimääräisen ja tässä tapauksessa turhan tiedon tallentamiselta jokaiseen tietueeseen, kun muutoin "turhaa" tietoa sisältävää pääavainattribuuttia ei tarvitse erikseen luoda; sen sijaan jo ennestään olemassa oleva attribuutti määritellään taulun pääavaimeksi.
Seuraavaksi esitellään yhdistetty pääavain ja vierasavain, sekä miten näiden avulla voidaan loogisesti yhteenkuuluvia, mutta eri tauluissa sijaitsevia, tietoja yhdistää toisiinsa liittyviksi.
 

2.3 Avainattribuutit: Tiedon yhdistäminen
Tietokanta koostuu käytännössä aina useammasta kuin yhdestä relaatiosta. Itseasiassa, relaatiomalli ei edes pyri esittämään tietoa mahdollisimman suurina ja vähälukuisina tauluina, vaan malli johtaa usein tietokantaan jossa on lukuisia pieniä tauluja. Taulujen välille synnytetään yhteyksiä, joiden avulla taulujen toisiinsa liittyvät tiedot "linkitetään" yhteenkuuluviksi. Linkki ei ole täysin korrekti termi, mutta riittää tarkastelun tässä vaiheessa kuvaamaan miten relaatiomalli yhdistelee tietoja taulusta toiseen. (Linkki-termin sopivuudesta tarkempi arvio luvussa 9)
Yksittäinen taulu esittää tietyn, mahdollisimman vähin attribuutein esitettävissä olevan joukon tietueita. Ideana on, että kun tietokannasta on tarve saada esiin halutut tiedot, koostetaan ne useista tällaisista tauluista niin että tiedon palasista syntyy tarvittava kokonaisuus.
On lukuisia syitä miksi relaatiomalli pyrkii juuri pieniin ja kompakteihin, sekä toisiinsa yhdistettyihin tauluihin suurien sijasta. Tähän palataan tuonnempana. Nyt riittänee tarkastella miten taulut relaatiomallissa yhdistyvät toisiinsa ja miten tällaisen pienen tietokannan voi hahmottaa. Samalla käsitellään taulun seuraava rakenneosa, vierasavain.
 

2.3.1 TYÖNTEKIJÄT JA PROJEKTIT; ESIMERKKITIETOKANTA
Alla on annettu neljä taulua, jotka ovat osa samaista tietokantaa, josta edellä esiteltiin taulu Työntekijä. Alla taulujen nimet ovat annettu niiden yläpuolella. Tuttu Tyontekija on myös mukana. Nyt mukana on useampi taulu, joskin edelleenkään ei koko tietokantaa. Taulujen alla on esitetty graafisesti miten tieto taulujen välillä "linkittyy." Rakenne sekä merkintätavat selitetään tämän jälkeen.

Projekti
 
	
	ProjektiID	Nimi	Aloitus	Lopetus	Asiakas
	1	Mars 2010 A	1/2004	6/2005	ESA
	2	Kivipojat / Tuotanto / 04	3/2004	12/2004	Joutsenon Kivipojat Oy
	3	Lappeenranta Laajennus	1/2003	4/2004	Lappeenrannan kaupunki
	4	Mars 2010 B	3/2005	6/2006	ESA
	5	Bussi '05	10/2004	10/2005	Liikennöitsijä Niemi Oy

Tyoskentelee
 
	
	TyontekijaID	ProjektiID	Rooli	Aloittaa	Vapautuu
	1	2	Projektipäällikkö	3/2004	12/2004
	1	5	Projektipäällikkö	9/2004	11/2005
	3	1	Sovelluskehittäjä	2/2004	6/2005
	4	4	Testauspäällikkö	1/2005	11/2005
	4	2	Sovelluskehittäjä	3/2004	1/2005
	5	1	Projektipäällikkö	10/2003	2010
	4	5	Sovelluskehittäjä	2/2005	10/2005

Tyontekija
 
	
	TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
	1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
	2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
	3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
	4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
	5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
	6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
	7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5

Toimipaikka
	
	ToimipaikkaID	Nimi	Osoite	PuhNumero
	Lpr	Lappeenranta Kareltek	Tietotie 2 F 5	05 1212556
	Hki-1	Helsinki Hirvitie	Hirvitie 10	01 7654321
	Hki-2	Pääkonttori	Kauppakatu 17	01 1234567
	Lontoo	London Office	Pine Avenue 100	018 5665411
 
Tietokantaan on tuotu kolme taulua lisää. Tyoskentelee, Toimipaikka ja Projekti. Nyt nähdään mihin projekteihin työntekijä osallistuu (tai osallistui) ja missä roolissa, ja millä ajanjaksolla. Edelleen nähdään tietoja projekteista sekä niiden aloitus- ja lopetusajankohdat. Toimipaikoista on annettu myös tietoja. On huomattavaa, että taulut ovat tarkoituksellisen suppeita esimerkin yksinkertaistamiseksi.
Miten sitten nähdään missä projektissa esimerkiksi Salla Sillanpää on ollut osallisena? Koska taulujen tiedot on yhdistetty pää- ja vierasavainparien kautta (tästä lisää alempana), emme voi suoraan nähdä työntekijän nimen perusteella missä projektissa hänellä on merkintöjä, tai onko missään. Sen sijaan on etsittävä haluamamme työntekijätietueen pääavainarvo -- Sallalle se on jo tuttu "3" -- ja katsottava Tyoskentelee-taulusta, mihin, jos mihinkään, projekteihin kyseinen TyontekijaID liittyy. Nähdään, että Tyontekija-arvolla "3" löytyy yksi tietue. Projektiksi on merkitty "1." Tämän perusteella voidaan Projekti-taulusta etsiä oikea tietue -- nyt se on heti ensimmäinen -- ja todeta että projekti on Euroopan Avaruusjärjestölle tehty ja "Mars 2010 A" nimetty.
Alempana on esitetty rakenne graafisesti.

Kuva 2: Projektitietokannan rakennekuvaus
 


Kuvassa taulun pääavain on merkitty lihavoituna, vierasavain kursivoituna ja pääavain joka samalla toimii myös vierasavaimena on merkitty sekä lihavoituna että kursivoituna. Taulujen väliset yhteydet on piirretty näkyviin viivoina, jotka yhdistävät avaintietueet eri tauluista. Taulun nimi on annettu ylimpänä, ja attribuutit on sitten listattu allekkain.
 

2.3.2 VIERASAVAIN
Tässä vaiheessa voidaan yleistää, että vierasavainattribuutti on jonkin toisen taulun pääavainattribuutti. Esimerkissämme Tyontekija-taulussa on vierasavain ToimipaikkaID. Koska työntekijätietueeseen on ollut tarve tallentaa tieto toimipaikasta, ja koska toimipaikkojen tiedoista on taulu, yhdistetään kukin työntekijä tiettyyn toimipaikkaan liittämällä työntekijään oikean toimipaikkatietueen pääavainarvo. Toimipaikka-taulussa pääavain on ToimipaikkaID -- sehän oli nimenomaan mikä yksilöi kunkin toimipaikan -- joten tämä ToimipaikkaID tuodaan attribuutiksi Tyontekija tauluun. Kutsumme sitä vierasavaimeksi (eli avain, joka vierailee toisessa taulussa.)
Vierasavain on täysi kopio pääavaimesta johon se liittyy. Näin ollen vierasavaimen TypaikkaID ja pääavaimen ToimipaikkaID välillä ei ole eroa -- niillä on sama arvoalue, tietotyyppi jne. Vierasavaimelle ei voi antaa arvoa, jota ei löydy sille pääavainarvona taulussa johon se liittyy. Tyontekija-tauluun ei voi siten antaa kenellekään ToimipaikkaID arvoa "Tre," koska sellaista ei Toimipaikka-taulussa pääavainarvona esiinny. Myöskään ei voida vierasavaimeksi antaa tyhjää arvoa: Vierasavaimen on aina viitattava olemassa olevaan pääavainarvoon.
Seuraavaksi katsotaan yhdistettyä pääavainta ja pää- ja vierasavainyhdistelmää.
 

2.4 Avainattribuutit: Yhdistetty pääavain
Jatkamme edellistä kappaletta laajentaen pää- ja vierasavaimen käsitettä tässä vaiheessa siinä määrin kuin yksinkertaisten tietokantojen käsitteleminen sitä vaatii. Tekstissä viitataan edelleen alla olevaan esimerkkitietokantaan.
 

Työntekijät ja projektit; esimerkki
Projekti
 
	
	ProjektiID	Nimi	Aloitus	Lopetus	Asiakas
	1	Mars 2010 A	1/2004	6/2005	ESA
	2	Kivipojat / Tuotanto / 04	3/2004	12/2004	Joutsenon Kivipojat Oy
	3	Lappeenranta Laajennus	1/2003	4/2004	Lappeenrannan kaupunki
	4	Mars 2010 B	3/2005	6/2006	ESA
	5	Bussi '05	10/2004	10/2005	Liikennöitsijä Niemi Oy

Tyoskentelee
 
	
	TyontekijaID	ProjektiID	Rooli	Aloittaa	Vapautuu
	1	2	Projektipäällikkö	3/2004	12/2004
	1	5	Projektipäällikkö	9/2004	11/2005
	3	1	Sovelluskehittäjä	2/2004	6/2005
	4	4	Testauspäällikkö	1/2005	11/2005
	4	2	Sovelluskehittäjä	3/2004	1/2005
	5	1	Projektipäällikkö	10/2003	2010
	4	5	Sovelluskehittäjä	2/2005	10/2005

Tyontekija
 
	
	TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
	1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
	2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
	3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
	4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
	5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
	6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
	7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5

Toimipaikka
	
	ToimipaikkaID	Nimi	Osoite	PuhNumero
	Lpr	Lappeenranta Kareltek	Tietotie 2 F 5	05 1212556
	Hki-1	Helsinki Hirvitie	Hirvitie 10	01 7654321
	Hki-2	Pääkonttori	Kauppakatu 17	01 1234567
	Lontoo	London Office	Pine Avenue 100	018 5665411


Kuva 2: Projektitietokannan rakennekuvaus
 

 

2.4.1 KAKSOISAVAIN
Taulu tyoskentelee näyttää edelleen erikoiselta vierasavaimen määritelmääkin vasten. Siinä on merkitty kaksi attribuuttia yhtäaikaa pääavaimiksi, mutta myös vierasavaimiksi.
Taulussa ei ole kahta pääavainta, sillä relaatiossa ei ikinä voi olla kuin yksi pääavain. Taulussa voi kuitenkin olla useita vierasavaimia. Tyoskentelee taulun pääavain on ns. yhdistetty, tai kaksoispääavain. Yhdistetty avain muodostuu yksinkertaisesti kahdesta, tai jopa useammasta, attribuutista yhtäaikaa. Tällöin pääavaimen arvo ei ole kummankaan attribuutin arvo, vaan niiden yhdistelmä.
Tyoskentelee taulussa nähdään seuraavia pääavainarvoja, ylhäältä lukien:
• "1 2"
• "1 5"
• "3 1"
• "4 4"
• "4 2" jne.
Ensimmäinen on siis yhdistelmä TyontekijaID "1" ja ProjektiID "2". Pääavainarvo ensimmäiselle tietueelle ei ole 1 eikä 2, eikä liioin "2 ja 1"; se on "1 ja 2". Toisen ja kuudennen tietueen pääavainarvot ovat "1 ja 5" sekä "5 ja 1". Ne ovat siten eri arvoja. Yhdistetty pääavain ei relaatiomallin kannalta poikkea yksinkertaisesta mitenkään: Sen arvo on oltava taulun jokaiselle tietueelle yksilöllinen ja se ymmärretään yhtenä arvona riippumatta kuinka useasta attribuutista se koostuu.
Miksi tällaista avainta sitten kannattaa tai täytyy käyttää? Yllä olevassa esimerkkitaulussa TyontekijaID ja ProjektiID yhdistetään toisiinsa. Jos pääavaimeksi valittaisiin tälle taululle vain toinen näistä -- esim. TyontekijaID -- ei pääavain olisi laillinen, sillä tokihan sama työntekijä voi esiintyä useissa projekteissa: Jo päättyneissä, meneillään olevassa, ja mahdollisesti tulevissa. Kuitenkin pääavain on oltava yksilöllinen taulun jokaiselle tietueelle, kuten jo on todettu.
Myöskään ei ProjektiID käy pääavaimeksi Tyoskentelee-taululle. Siinä on sama vika. Pääavainarvon yksikäsitteisyys ei säily tai sitä ei voida taata. Mutta näiden yhdistelmä voi toimia avaimena, koska se on yksilöllinen jokaiselle tietueelle. Kuten nähdään, voi nyt sama työntekijä olla läsnä vaikka kuinka monessa projektissa, ja toisaalta, voi samaan projektiin liittyä useita työntekijöitä.
 

2.4.2 PÄÄAVAIN VIERASAVAIMENA
Tyoskentelee-taulussa piilee myös toinen mielenkiintoinen piirre. Sen pääavaimen osat toimivat samalla vierasavaimina. TyontekijaID on Tyontekija taulun pääavain, joten Tyoskentelee taulussa se on siis vierasavaimena. Sama ProjektiID:lle Projekti tauluun nähden. Nämä vierasavaimet on tässä taulussa otettu myös pääavaimiksi, kuten yllä esitettiin. Sama attribuutti voi siten olla sekä vieras- että pääavain samalla kertaa, eikä tämä ole lainkaan harvinaista.
Tyoskentelee taululle olisi voitu myös luoda aivan uusi attribuutti pääavaimeksi. Esim. kuten alla.
Tyoskentelee
OsallistuminenID	TyontekijaID	ProjektiID	Rooli	Aloittaa	Vapautuu
1	1	2	Projektipäällikkö	3/2004	12/2004
2	1	5	Projektipäällikkö	9/2004	11/2005
3	3	1	Sovelluskehittäjä	2/2004	6/2005
4	4	4	Testauspäällikkö	1/2005	11/2005
5	4	2	Sovelluskehittäjä	3/2004	1/2005
6	5	1	Projektipäällikkö	10/2003	2010
7	4	5	Sovelluskehittäjä	2/2005	10/2005
 
Tässä taulussa pääavaimena olisi OsallistuminenID, joka määrittää aina yksilöllisen osallistumis"instanssin" tms. TyontekijaID ja ProjektiID olisivat nyt tavallisia vierasavaimia.
Kumpi on parempi tapa toteuttaa kyseinen relaatio? Jos on mahdollista, että samalla työntekijällä voi olla eri työjaksoja samassa projektissa esim. eri rooleissa, ja siten sama työntekijä - projekti pari voi esiintyä, olisi pakko valita tämä jälkimmäinen toteutus. Muutoin edeltävä on yksinkertaisempi, koska ylimääräistä pääavainattribuuttia ei tarvitse luoda. Siinä sama osallistumistapahtuma, joka tässä on omana ID:nä, kuvataan yhdistelmäavaimena ja sen arvona.
Alla on vielä graafinen esitys tietokannasta tilanteessa, jossa Tyoskentelee olisi laadittu ylläkuvatunlaisesti.
 
Kuva 3: Tyoskentelee taulu ilman kaksoispääavainta



2.5 Relaatiomalli ja tiedon yksikäsitteisyys
Kun nyt tiedetään, miten tietoa esitetään relaatiotietokannassa relaatioiden eli taulujen kautta, voi herätä kysymys, mihin tauluun tai tauluihin jokin attribuutti tai yksittäinen tietoalkio sijoitetaan?
Seuraavassa kappaleessa, joka paneutuu tietokannan rakenteen suunnitteluun, nähdään miten taulujen rakenne voidaan määrittää systemaattisesti ja loogisesti; tauluja ei suinkaan roiskita vain tietokantaan näppituntumalla. On kuitenkin hyvä jo relaatiomallin yhteydessä painottaa mallin keskeistä ominaisuutta, jota monesti näkee rikottavan.
 

2.5.1 TIEDON TOISTUMINEN
Relaatiomallin lähtökohta on, että yksittäinen tieto esiintyy tietokannassa vain kerran. Tämä tarkoittaa, että samaa tietoa ei tulisi ikinä esittää kahdessa eri taulussa. (Ellei kyseessä ole vierasavainattribuutti, joka toki vaatii pääavainarvojen toistamista vierastaulussa.) Mitä tämä tarkoittaa käytännössä?
Tarkastellaan alla olevaa rakennetta.
Kuva 4: Rakenne, jossa samaa tietoa toistetaan eri tauluissa

 
Samaa tietoa toistetaan eri tauluissa. Tämä on ilmeistä: Tuote-taulussa on annettu tuotteen nimi. Kuitenkin Kampanja-taulussa annetaan myös tuotteelle nimi. Kun tuotteelle merkitään kampanjatieto tähän tauluun, annetaan sama nimi uudestaan; sama joka on Tuote-taulussa jo kertaalleen ilmoitettu. Varasto-taulussa on kaksi samaa attribuuttia kuin Tuote-taulussa: Hyllypaikka ja MaaraHyllyssa.
Miksi tämä on ongelma?
Ongelma syntyy siitä, että kahdessa eri paikassa olevan saman tiedon ylläpitäminen on ongelmallista. Mitä jos tuotteen hyllypaikka muuttuu? Muistetaanko se päivittää myös Varasto-tauluun? Entä jos yhtäkkiä havaitaan, että kahdessa taulussa on eri arvo attribuutille MaaraHyllyssa. Kumpi on oikea määrä? Pitää käydä laskemassa. Isossa tietokannassa tällainen tilanne olisi kestämätön: Valtaisia määriä dataa voisi korruptoitua tällaisen seurauksena.
 

2.5.2 TIEDOLLA ON VAIN YKSI PAIKKA!
Minne tieto sitten kuuluu? Se kuuluu vain yhteen paikkaan. Tämä tarkoittaa, että samaa attribuuttia ei saa toistua kahdessa eri taulussa, ellei kyseessä ole avainyhteys. Tämä myös tarkoittaa, että samaa tietoa ei saa esiintyä eri nimellä toisessa paikassa -- ilmiö joka on paljon yleisempi ja voi helposti jäädä äkkiseltään huomaamatta. Laajempi esimerkki tästä ongelmasta nähdään luvussa 7.
Todetaan tässä, että jokaiselle tiedolle on löydyttävä sen oma taulu. Relaatiomallin kulmakivi on: "Tieto voi esiintyä vain yhdessä taulussa, ja vain yhdessä attribuutissa. Poikkeuksena ovat avainyhteydet." Seuraavassa luvussa käsitellyin suunnittelumenetelmin tämän periaatteen noudattaminen pitäisi olla helpompaa ja tulla luontevaksi. On kuitenkin hyvä pitää tietokannan rakennetta analysoidessaan tämä mielessä.
Alle on vielä annettu yksi mahdollinen ratkaisutapa yllä olevalle tiedon toistumisongelmalle. On nyt mielipidekysymys, mihin nämä toistuvat tiedot sijoitetaan. Tässä on päädytty seuraavanlaiseen sijoitteluun.
 
Kuva 5: Tiedon toistuminen poistettu: yksi useista ratkaisutavoista

 

2.6 Keskeisiä termejä suomeksi ja englanniksi
Taulu, taulukko, relaatio; table, relation (relvar)
	Relaatiomallissa kaikki tieto esitetään pelkästään taulujen kautta. Kts. taulun rakenne kuvassa 1. Attribuutit ovat osa taulun rakennetta / ominaisuuksia, tietueet taas esittävät tietoa taulun rakenteen mukaisesti.
Rivi, tietue; row, tuple
	Tietueet esittävät tietoa taulun attribuuttien määrittämällä tavalla. Yksittäinen tietue sisältää yksittäisen arvon kullekin attribuutille.
	 
Attribuutti; attribute
	Määrittävät mitä tietoja ja missä muodossa tietueet sisältävät.
Pääavain ja vierasavain; primary key and foreign key
	Jokaisella taululla on oltava pääavain, ja se voi koostua useammasta kuin yhdestä attribuutista. Pääavainarvo on oltava jokaiselle tietueelle yksilöllinen. Vierasavaimen avulla voidaan luoda looginen yhteys kahden taulun välille, yhdistämällä pääavain toisen taulun vierasavaimeen.

Kenttä, solu; cell
	Kenttä sisältää yksittäisen tiedon / tietoalkion. Tietue koostuu kentistä.

3. Suunnittelun perusteita
11. Johdanto
12. Käsiteanalyysi ja käsitekaavio
13. Käsitekaavio
14. M:N asteisten yhteyksien käsittely
15. Käsitekaavioesimerkki
16. Laajennettu versio käsitekaaviosta
17. Keskeisiä termejä suomeksi ja englanniksi

3.1 Johdanto
Edellä on kuvattu joitain relaatiomallin keskeisimpiä piirteitä ja näytetty, miten tietoa esitetään relaatioiden avulla ja toisaalta miten luodaan loogisia yhteyksiä tietueiden välille avainattribuuttien avulla.
Seuraavaksi katsotaan, miten tällainen tietokantarakenne voidaan suunnitella. Onhan selvää, että ennenkuin voidaan käyttää SQL-lauseita taulujen ja tietokannan luomiseen, on voitava tietää, mitä ollaan tekemässä: Mitä tauluja tietokannassa on? Mikä on niiden rakenne? Onko taulujen A ja B välillä avainyhteyttä?
Toisaalta, pitäisi myös varmistua, että tietokannan kohteena oleva asia tulee oikealla tavalla mallinnetuksi juuri relaatiotietokannan asettamien rajoitteiden ja toisaalta mahdollisuuksien puitteissa. Voitaisiin pohtia, oliko edellä käytössä ollut projektitietokanta rakenteeltaan korrekti ja vastasiko se ylipäätään sille asetettua tarvetta. Miten tällainen arvio voitaisiin tehdä?
Tässä luvussa käydään aivan perusteiltaan läpi tyypillinen tapa suunnitella relaatiomallia noudattava tietokanta. Tuloksena saadaan rakennekuvaus, jonka perusteella voidaan tietokanta luoda SQL-kielen avulla. Toisin sanoen, ensin laaditaan piirustukset, ja vasta tämän jälkeen lähdetään rakentamaan.
Pienen, simppelin tietokannan voi jo vähäisenkin kokemuksen perusteella luoda lähes suoraan ilman isompaa suunnittelua. Silloinkin on tunnettava joitain rakenteeseen liittyviä yksityiskohtia, jotka tulevat tutuiksi käsitekaavioihin tutustumisen myötä. Tällaisia ovat mm. taulujen välillä vallitsevat niin sanotut "monen-suhde-moneen" laatua olevat avainyhteydet, joiden tunnistaminen on tärkeää aivan pienissäkin tietokannoissa, jotta ne toimisivat oikein.
Aloitamme käsiteanalyysillä ja käsitekaaviolla. Suunnittelusta laajemmin ja tarkemmin kerrotaan luvussa 10. Lisäksi esittelemme normalisointitarkistukset osana suunnittelua kurssin viimeisessä luvussa. Tässä vaiheessa katsotaan suunnittelua siltä osin kuin se on tarpeen pienten tietokantojen luomiseen SQL-kielellä.
 

3.2 Käsiteanalyysi ja käsitekaavio
Luonteva tapa lähestyä tietokannan suunnittelua on ns. käsiteanalyysi. Siinä tietokannan looginen rakenne luodaan asteittain etsien kohdealueesta tiettyjä, mallinnettavissa olevia asioita ja ilmiöitä. Tuloksena on käsitekaavion nimellä tunnettu kuvaus tietokannan loogisesta rakenteesta. Käsitekaavion perusteella on tämän jälkeen mahdollista luoda itse relaatiomallia noudattava tietokanta. Mikäli käsitekaavio on tehty huolella, voidaan itse SQL-toteutusvaiheessa olla varmoja rakenteen oikeellisuudesta, eikä tauluja luotaessa tarvitse enää keskittyä rakenneteknisiin kysymyksiin, tai mikä työläintä, muuttaa rakennetta enää myöhemmässä vaiheessa, mihin huono tai kokonaan pois jätetty suunnittelu usein johtaa.
3.2.1 KÄSITEANALYYSI
Alla on yksinkertaistettu esitys käsiteanalyysin etenemisestä. Ongelma-alueen analyysin avulla luodaan käsitekaavio; se yleensä muuttuu analyysin aikana suuntaan jos toiseenkin uusien havaintojen ja korjausten myötä. Käsitekaaviosta, joka sinänsä ei ole tietomalli-riippuvainen, voidaan sitten johtaa relaatiomallin mukainen rakenne. Tämä on varsin suoraviivainen prosessi -- käsitekaavion elementit vain muutetaan relaatiomallin vastaaviksi. Relaatiomallin mukainen esitys voidaan nyt toteuttaa tietokannaksi esim. SQL:n avulla valmiin "piirrustusten" pohjalta. Tarkempi vaihekuvaus käsiteanalyysistä esitetään luvussa 10.
 
 
Kuva 1: Käsiteanalyysin vaiheita

 

3.3 Käsitekaavio
Suunnittelun aikana luodaan käsitekaavio. Mistä käsitekaavio koostuu ja mitä siihen tulee mallintaa?
Käsitekaavion tärkeimmät elementit ovat yksilötyypit, ominaisuustyypit ja yhteystyypit. Näiden ohella malli sisältää tavallisesti myös relaatiomallista tuttuja eheyssääntöjä. Toisessa suunnitteluluvussa laajennetaan käsitekaaviota tästä, mutta yksinkertaisten, ja vähän laajempienkin, tietokantojen luomiseen riittää jo tämä mallinnusaste.
3.3.1 YKSILÖTYYPPI
Yksilö tai yksilötyyppi on jokin kohdealueelta löydetty, mallinnettava, ja tietokannan kannalta jollakin tapaa hyödyllinen olio, joka voi olla todellinen tai abstrakti. Tyypillinen olio voisi olla vaikkapa opiskelija, työntekijä, tilaus, projekti, artistin esiintyminen jne. Yksilötyyppi on siis eräänlainen luokka, johon kuuluvia yksilöitä on olemassa. Nämä yksilöt ovat ominaisuuksiltaan samankaltaisia. Mallissa, johon liittyy esiintyviä artisteja, voidaan todeta, että yksilötyyppien artisti ja manageri ohella esimerkiksi esiintyminen/keikka on myös kiinnostava asia, ja tällä asialla on lukuisia esiintymiä, joilla kaikilla on tiettyjä yhteisiä ominaisuuksia (aika, paikka, jne.). Voidaan siis luoda yksilötyyppi esiintyminen.
Löydetyt yksilötyypit listataan alustavasti. Myöhemmin niistä osa voi karsiutua pois turhina, tai muuttua ominaisuustyypeiksi (kts. alempana). Kun käsitemalli on valmis, muuttuvat yksilötyypit relaatiotietokannassa aina tauluiksi.
Yksilötyypille voidaan löytää myös ns. alityyppi. Se on "isäntä" yksilötyypin jokin ilmentymä, joka on syystä tai toisesta tarpeen mallintaa erikseen. Alityyppejä voisi esim. yksilöllä Asiakas olla yksityinen ja yritys, kun tiedetään, että on merkittävä ero onko asiakas yksityinen- vai yritysasiakas. Kuitenkin kummallakin alityypillä on myös yhteisiä "asiakas" ominaisuuksia. Jos näin ei olisi, voisi niistä luoda myös täysin itsenäiset yksilötyyppinsä.
	Käsitekaaviossa yksilötyyppiä voidaan merkitä vaikkapa seuraavanlaisella soikiolla tai vastaavalla muodolla. Alityypit on tässä merkitty liittymään yksilötyyppiin UML-kaavioista tutulla "perii" nuolella.
Kuva 2: Yksilötyyppi, jolla kaksi alityyppiä.
 

 

3.3.2 YHTEYSTYYPPI
 
Kahden yksilötyypin välistä riippuvuutta kuvataan yhteystyypillä. Jos yksilötyyppi vastaa relaatiomallissa taulua, vastaavat yhteystyypit taulujen välisiä avainyhteyksiä, joita luotiin pää- ja vierasavainpareilla. Samanlaiset yhteydet muodostavat siten yhteystyypin: Artistin ja Keikan välillä esiintyy havaitun yhteystyypin mukaisia yhteyksiä.
Näin ollen löydettyjä yhteystyyppejä voisivat olla esimerkiksi Yritys → Työntekijä tai Opiskelija → OsallistuaKurssiille → Kurssi. Viimemainitussa on havaittu kaksi yhteystyyppiä.
Yhteystyyppejä määriteltäessä ei vielä mietitä relaatiomallin avaimia sinänsä, vaan pää- ja vierasavaimet päätetään vasta kun kaikki yhteydet on saatu valmiiksi eikä muutoksia enää ole näköpiirissä.
Yhteystyypille on olemassa kolme eri "astetta", jota se voi noudattaa. Kullekin yhteystyypille on tällainen aste määritettävä, ja se merkitään näkyviin käsitemalliin. Asteet ovat: 1:1, 1:N sekä M:N; ne luetaan “yhden suhde yhteen”, “yhden suhde moneen” ja “monen suhde moneen”. On tärkeää tietää, että M:N suhde ei ole sallittu valmiissa relaatiotietokannaksi muutettavassa käsitekaaviossa ja tällainen suhde on purettava kahdeksi 1:N tyyppiseksi suhteeksi. Tästä kerrotaan lisää hiukan alempana.
Suhteessa katsotaan olevan "vanhempi" ja "lapsi" yksilötyypit, ja suhteen aste kertoo, "miten monta liittyy miten moneen" niin, että ilmoitetaan "näin moneen vanhempaan" liittyy "näin monta lapsiyksilötyyppiä" tämän yhteystyypin vallitessa. Alla olevat esimerkit valottavat asiaa.
Eriasteisia suhteita:
1:1 Rehtori → Koulu, Kaupunki → Pormestari, jne...
	Yhteen kouluun liittyy yksi rehtori ja toisaalta yhteen rehtoriin liittyy yksi koulu. Koulullahan on aina rehtori, ja häntä on vain yksi (jos katsotaan vararehtori erikseen). Rehtori on vain yhden koulun rehtori. Suhde on siis tyyppiä 1:1. Pormestariin liittyy yksi kaupunki ja kaupunkiin liittyy yksi pormestariin, aivan kuten edelläkin. Merkitään suhteeksi 1:1. Tämänasteisessa suhteessa kumpi tahansa voi olla vanhempiyksilö.
1:N Koulu → Oppilas, Yritys → Tyontekija, Pankki → Konttori, jne...
	Kouluun liittyy useita oppilaita, mutta oppilaat liittyvät yhteen kouluun. Jos ajatellaan vaikkapa peruskoulua, niin koulussa on toki useita oppilaita, jotka käyvät tätä koulua. Oppilas taasen kuuluu vain yhteen kouluun. Toiseen liittyi useita yksilöitä (yksilötyypistä oppilas), toiseen liittyy aina vain yksi yksilö (yksilötyypiltään koulu). Suhde on 1:N. Yrityksellä on vastaavasti työntekijöitä, mutta työntekijä liittyy vain yhteen yritykseen kerrallaan (ainakin tässä tietokannassa). Samoin pankilla on useita sivukonttoreita, mutta jokainen konttori kuuluu yhteen pankkiin. Tässä suhdeasteessa vanhempi on se, jota on yksi, ja lapsiyksilöitä taas voi olla useita.
M:N Kokous → Osallistuja, Esitieto → Kurssi, Opiskelija → Kurssi, Bändi → Artisti jne...
	Kokouksella on useita osanottajia, mutta osallistuja voi olla läsnä useassa eri kokouksessa. (Tai on mahdollista olla näin!). Opiskelija osallistuu kursseille ja kurssiin liittyy opiskelijoita. Bändi voi esiintyä eri artistien kanssa, ja artisti ei aina esiinny saman bändin kanssa.
 
Olennaista suhteiden asteiden määrityksissä ei ole mitä tapahtuu "maailmassa oikeasti." Olennaista on, mikä on mallinnettavien yksilötyyppien välinen suhde. Jos kohdealueella koululla voi vain olla yksi rehtori, niin silloin suhde määritetään tämän pohjalta. Toinen olennainen seikka on, että mikäli on mahdollista, että yhteenkään yksilöön A voi liittyä enemmän kuin yksi yksilö B, on suhde oltava 1:N. Samoin on merkittävä asteeksi 1:N, jos N päässä voi esiintyä nolla, eli ei yhtäkään yksilöä. 1:1 on mahdollinen vain jos jokaisesta A yksilöstä on aina suhde yhteen B yksilöön, ja toisinpäin. Vastaavasti M:N tarkoittaa yhteyttä nollaan tai useampaan, mutta toisin kuin 1:N suhteessa, molemmin päin.
Alla on esitetty kaksi eri tapaa merkitä yhteystyyppien asteet. Toisessa käytetään 1 ja N merkintöjä; toisessa suhteen N päätä on merkitty kahdella nuolella, ja 1 päätä yhdellä nuolella.
 
Kuva 3: Yhteystyyppien asteet merkitty kahdella eri tavalla
 

 
 
On myös hyvä huomata, että etsittäessä yhteystyyppejä, tulee lopulta löytyä yhteys kaikkien yksilötyyppien välille niin, että syntyvään käsitekaavioon ei jää irrallisia "saarekkeita", joista ei olisi yhteyttä lainkaan johonkin toiseen rykelmään tai yksittäiseen yhteystyyppiin. Toisin sanoen, jokaisesta yksilötyypistä on, yhteyksiä seuraten, voitava päästä jotakin reittiä kaikkiin muihin yksilötyyppeihin. Alla olevassa hahmotelmassa on kolme tällaista irrallista rykelmää. Valmiissa käsitekaaviossa ei näin saa olla.
 

 

3.3.3 OMINAISUUSTYYPIT
Yksilötyypin yksilöiden jakamia yhteisiä ominaisuuksia, jotka ovat mallin kannalta kiinnostavia, kutsutaan ominaisuustyypeiksi. Samanlaiset ominaisuudet ovat samaa tyyppiä. Relaatiomallissa ominaisuustyypeistä tulee taulun attribuutteja. Näin ollen myös avaimet on attribuutteja, minkä vuoksi ne voidaan määrittää kun kaikki ominaisuustyypit on kirjattu. Tätä ennen tulee yhteystyyppien olla tietenkin selvillä.
On myös syytä kriittisesti tarkastella, onko jokin asia ominaisuustyyppi, vai joudutaanko tässä vaiheessa luomaan vielä kokonaan uusia yksilötyyppejä. Jos yksilötyypille ei synny ominaisuustyyppejä, voidaan se joutua muuttamaan ominaisuustyypiksi jollekin toiselle yksilötyypille. Ominaisuustyypit voidaan haluttaessa merkitä käsitekaavioon näkyviin suoraan, tai ne voidaan kirjata erikseen. Alla olevassa mallissa ne on merkitty näkyviin ja siten, että yhteystyyppeihin liittyvät avaimet on myös määritetty ja merkitty näkyviin.
 
Kuva 4: Ominaisuustyypit merkittynä käsitemalliin.
 

 

3.3.4 EHEYSSÄÄNNÖT
Tässä yhteydessä käsitemallia tarkastellaan varsin suppeasti. Tarkasteltavana ei esimerkiksi ole ehdollisia yhteystyyppejä eikä ns. toisioavaimia. Näitä tarkastellaan luvussa 10. Laajoja tietokantoja luotaessa merkittävässä roolissa ovat näiden ohella myös mallin eheyssäännöt. Ne ulotetaan koskemaan niin  tiedon lisäyksiä kuin tiedon poistojakin, ja ne voivat olla yksilö- tai ominaisuustyyppikohtaisia; esimerkiksi, eheyssääntö voi määrittää, onko sallittua poistaa yksilötyypin A mukainen yksilö, jos sillä on yhteys tiettyyn toiseen yksilöön B? Tai, voiko oppilasta tuoda tietokantaan ilman että hän liittyy mihinkään kouluun? Pääavainten ja vierasavainten määritykset luovat myös merkittäviä eheyssääntöjä, joita harkitaan avaimia määritettäessä.
Luvussa 16 tarkasteltava normalisointimenettely ja siihen lukeutuvat normalisointitarkistukset kuuluvat usein myös käsiteanalyysiin eräänlaisena valmiin käsitekaavion tarkistustoimina.
Kun pohditaan yksinkertaisempien ja pienten tietokantojen rakennetta, tulevat monet eheyteen liittyvät seikat luonnostaan, esimerkiksi juuri avaimet. On kuitenkin hyvä pitää mielessä, että tietokannalle voi olla tarpeen määrittää erityisiä, relaatiomallin teknisten määritteiden yli meneviä eheyssääntöjä, jotka ovat enemmänkin juuri ihmistä eli käyttäjää varten tarkoitettuja: Mitä voi lisätä tai mitä voi muuttaa, ja millä ehdoilla? Tällaiset eheyssäännöt luetaan käsitemallista, ja relaatiotietokantatoteutuksen yhteydessä implementoidaan tauluihin tai attribuutteihin käytettävän TKHJ:n puitteissa.
 

3.4 M:N asteisten yhteyksien käsittely
Edellä on todettu, ettei valmiiseen käsitemalliin, joka toteutetaan relaatiotietokannaksi, voi jättää M:N (monen suhde moneen) asteisia yhteystyyppejä. Usein tällaisia yhteystyyppejä kuitenkin löydetään. Miten tulisi toimia?
 

3.4.1 YHTEYSYKSILÖTYYPPI
Ratkaisu M:N ongelmaan on purkaa yhteys siten, että luodaan, joskin keinotekoisesti, M:N osapuolten väliin yhteysyksilötyyppi, jonka avulla M:N aste muuttuu kahdeksi 1:N asteiseksi yhteystyypiksi. Tämä uusi yksilötyyppi on varsin keinotekoinen, mutta sen tehtävänä on toimia "yhteys tapahtumaa" kuvaavana yksilötyyppinä. Tällainen voisi olla alla kuvatun kaltainen "projektiin osallistuminen", joka luodaan Projekti ja Työntekijä yksilötyyppien väliin. Yhteysyksilötyypin yksilöt ovat osallistumistapahtumia.
Tarkastellaan alla olevaa tilannetta. Projekti ja Työntekijä -yksilötyyppien välillä on havaittu M:N asteinen suhde. Projektiin liittyy (=osallistuu) useita työntekijöitä, ja toisaalta työntekijällä on mahdollisuus olla mukana useissa projekteissa. Tilanne on tuttu edellisen kappaleen esimerkkitietokannasta.
 
Kuva 7: Yhteysyksilötyypin käyttö
 

 
Kuvasta nähdään, miten M:N yhteys muuttuu väkisin kahdeksi 1:N asteiseksi yhteydeksi, kun väliin sijoitetaan uusi yksilötyyppi. Työntekijään voi liittyä nyt 0..1..N osallistumista. Osallistumiseen liittyy aina yksi työntekijä. Toisaalta, projektiin voi liittyä 0..1..N osallistumista, mutta osallistuminen liittyy aina yksittäiseen projektiin. Ratkaisu ei ole enää yhtä intuitiivinen, mutta tämä ei ole tarkoituskaan, vaan M:N suhde on aina pakko purkaa jollakin tavalla. Alla nähdään vielä taulujen mahdollinen rakenne. Huomaa Projektitietokannasta tuttu kaksoispääavain Osallistuminen-taulussa. Kaksoisavaimen muodostavat attribuutit ovat samalla myös vierasavaimia, ja siksi ne on merkitty myös kursiivilla. Yhteysyksilötyypeille on ominaista, että niihin syntyy kaksois- tai jopa useampiosaisia pääavaimia.
Kuva 8: Taulujen rakenne
 

 

3.4.2 KOLMOISAVAIN?
Yhteysyksilötyyppi voi toimia yhdistäjänä kahden, mutta myös useamman yksilötyypin välissä. Ei ole mitenkään tavatonta, että yhteystauluun tulee tällöin kolmoisavain. Toisaalta, kuten jo edellisessä luvussa esitettiin, voidaan tällaisessa yhteystaulussa käyttää aivan omaa pääavainta, ja tuoda yhteys muista tauluista tavallisina vierasavaimina. Näin tehtiin Projektitietokannan Tyoskentelee-taulun toisessa versiossa, jota tarkasteltiin luvussa 2.
M:N yhteyden purkamisen nyrkkisääntö on, että väliin luodaan yhteysyksilötyyppi, ja että kumpikin, tai kaikki, M:N yhteydessä olleet yksilötyypit, yhdistetään tähän uuteen yhteysyksilötyyppiin sen sijaan että ne olisivat suoraan yhteydessä toisiinsa. Tarvittaessa voidaan käyttää kolmoisavaintakin. Itse yhteysyksilötypin kannalta on muistettava pääavainten ja vierasavainten perusteet: On oltava mahdollista luoda yksikäsitteisiä yhdistelmiä, ja ei saa olla mahdollista, että sama yhdistelmä toistuu. Tämän perusteella valitaan sopiva rakenne.
Seuraavaksi nähdään esimerkki kokonaisesta käsitekaaviosta ja minkälaisia tauluja siitä syntyisi. Samalla nähdään lisäesimerkkejä yhteysyksilötyypeistä.
 

3.5 Käsitekaavioesimerkki
Tässä kappaleessa esitetään laajempi esimerkki käsitekaaviosta, joka on laadittu tässä luvussa esitetyin menetelmin. Ensiksi annetaan mallinnettavan kohdealueen kuvaus, minkä jälkeen esitetään ensimmäinen versio käsitemallista. Mallin ohessa tarkastellaan mahdollista relaatiotietokantatoteutusta, jonka jälkeen mallista laaditaan vielä toinen, laajempi versio.
 

3.5.1 KÄSITEMALLIN KOHDE
Tarkoituksena on ensimmäisessä versiossa laatia tietokanta, ja siten ensin käsitemalli, jalkapallo, jääkiekko tms. joukkuepelin junioriliigan käyttöön. Tietokannasta tulisi löytyä tiedot joukkueista ja niiden pelaajista. Tämän lisäksi halutaan tiedot kunkin pelaajan huoltajista. Tietokannasta tulisi myös saada tiedot pelien tuloksista, ja pelaajien pistetilanne (maalit, syötöt, tehopisteet).
Alla on kuvattu eräs yksinkertaisimmista tavoista toteuttaa käsitemalli.
 
Kuva 5: Junioriliigan käsitemalli

 
Pelaajan ja Huoltajan välillä oli havaittu M:N suhde. Samalla pelaajalla voi olla enemmän kuin yksi huoltajamerkintä, esimerkiksi molemmat vanhemmat tai jopa useampi henkilö joiden yhteystiedot on haluttu luovuttaa. Toisaalta, samaan huoltajaan voi liittyä useita pelaajia. Suhde on purettu yhteysyksilötyypillä, ja sen nimi on hiukan teennäinen "Huoltaa." Se voisi olla myös "Huoltajuussuhde" tms. Pisteet ja Pelaaja ovat 1:1 suhteessa: Pelaajalla on yksi pistetieto (syötöt, maalit, jne.), ja "pelaajan pisteet" liittyvät kerrallaan aina yhteen pelaajaan. Joukkue → Pelaaja on 1:N, sillä pelaaja kuuluu yhteen joukkueeseen ja joukkueessa on useita pelaajia. Jos olisi mahdollista että pelaaja voi kuulua useampaankin joukkueeseen, tulisi suhteelle M:N aste.
Sama pätee Valmentaja → Joukkue suhteeseen. Jos valmentaja voisi olla usean joukkueen valmentaja samanaikaisesti, syntyisi M:N suhde. Tässä on tyydytty yksinkertaisuuden vuoksi päätelmään, jonka mukaan valmentaja on kerrallaan yhden joukkueen valmentaja. Joukkueella voi sen sijaan olla enemmän kuin yksi valmentaja. Joukkue → Ottelu voitaisiin merkitä 1:N suhteeksi, mutta selvyyden vuoksi on esitetty, että joukkueella on kahdenlainen suhde Otteluun: Koti- ja vierasjoukkueena. Tämä nähdään alla olevassa relaatiotaulujen rakennekuvauksessa. Muunkinlainen toteutus olisi mahdollinen.
Ylläkuvatunlainen suhde Ottelun ja Joukkueen välillä on esitetty kahdella yhteystyypillä, jotta vältyttäisiin ymmärtämästä suhde väärin M:N asteiseksi. Yhtä Ottelu yksilöä kohden voi vain olla yksi joukkue sekä kotijoukkueena että vierasjoukkueena. Sen sijaan joukkue voi esiintyä useita kertoja kotijoukkueena tai vierasjoukkueena eri otteluissa. Yhdessä ottelussa on kuitenkin vain yksi kotijoukkue ja yksi vierasjoukkue. Näin suhde ei ole astetta M:N. Täten myös Ottelu tauluun tulee kaksi vierasavainta: Kotijoukkue ja vierasjoukkue. Kumpikin yhteystyyppi vaatii oman avaimensa.
Alle on hahmoteltu mallista johdettu ehdotus relaatiotietokannan taulujen rakenteeksi. Se voisi olla hyvin erilainenkin. Taulun rakenteen yhteydessä on esitetty myös ehdotus attribuutin tietotyypiksi.
 
Kuva 6: Junioriliigan taulujen rakenne ja mahdollinen toteutustapa.

Pisteet-taulussa nähdään Pelaaja-taulun pääavain vierasavaimena, joka on samalla myös pääavain. Huoltaa-yhteysyksilötyyppi muunnettiin aiemmin esitellyllä tavalla tauluksi, jossa kummankin yhdistetyn taulun pääavaimet tuodaan yhdistetyksi pääavaimeksi, joka on samalla myös vierasavainpari. (kts. edellinen kappale yhteysyksilötyypeistä) Ottelu-taulussa nähdään kaksi vierasavainta Joukkue-taulusta yllä esitettyyn tapaan: Kumpikin on vierasavain JoukkueID:lle. Ottelu taulussa tuloskoodi tarkoittaa joko tasapeliä, tai koti- tai vierasjoukkueen voittoa. Itse tuloslukema on annettu tavallisena tekstinä, esim. "1 - 3".
 

3.6 Laajennettu versio käsitekaaviosta
Käsitekaaviota on laajennettu tuomalla siihen tietoja otteluiden toimitsijoista, joita voivat olla päätuomari, kakkostuomari ja mahdollinen virallinen valvoja (tai vastaava). Lisäksi on haluttu tiedot pelipaikoista, esim. kentän tarkka osoite ja mahdollisia pelipaikan aukioloaikoja.
 

3.6.1 MAHDOLLINEN RATKAISUTAPA
Ehdotelma tällaisesta laajennetusta versiosta on annettu alla. Joukkue → Ottelu on nyt merkitty yksinkertaisesti pelkällä 1:N suhteella. Ottelu → Toimitsija havaittiin olevan M:N asteisessa suhteessa, sillä ottelussa voi olla läsnä useitakin toimitsijoita, esim. kaksi valvojaa tai kaksi 2. tuomaria. Yhteys purettiin yhteysyksilötyypillä, kuten on jo nähty aiemminkin.
Malliin on merkitty mahdollisia alityyppejä. Esimerkiksi ottelu voi olla virallinen tai epävirallinen ottelu. Toimitsijalla on kolme alityyppiä. Käsitemallin lopullisessa versiossa tulee päättää, ovatko alityypit relevantteja, eli onko niillä merkitystä tietokannan näkökulmasta. Jos näin ei ole, poistetaan turhat alityypit. Ottelu tauluun voidaan tuoda ylimääräinen attribuutti "Ottelutyyppi" tms, joka voi saada arvon "Virallinen" tai "Epävirallinen". Jos näin toimitaan, olisi perusteltua ilmoittaa alityypillä tämä jako ja näin jättää Ottelu yksilötyypin alityypit näkyviin.
 
Kuva 7: Laajennettu käsitekaavio junioriliigalle
 

 

 
3.7 Keskeisiä termejä suomeksi ja englanniksi
Käsitekaavio, -malli; semantic model
	Käsiteanalyysin tuloksena syntyvä kuvaus tietokannan rakenteesta.
Yksilötyyppi, yksilö, olio; entity
	Käsitekaavion rakenneosa. Relaatiotietokannassa taulu/relaatio.
Ominaisuustyyppi; attribute
	Yksilötyypin ominaisuus, joka on tärkeä mallinnettavan asian kannalta. Relaatiotietokannassa attribuutti. Ominaisuustyypeistä valitaan avainattribuutit.

Yhteystyyppi; relationship
	Voivat olla kolmea eri astetta: 1:1, 1:N tai M:N. M:N yhteyksiä ei voida jättää käsitekaavioon, josta tulee relaatiotietokanta. Käsitemallissa ei saa olla yksilötyyppejä, joihin ei liittyisi yhtäkään yksilötyyppiä. Ei myöskään saa esiintyä yksilötyyppisaarekkeita, joista ei olisi yhteyttä toiseen ryhmään yksilötyyppejä.

4. SQL johdanto
18. SQL-kieli, kertaus
19. Tietokanta CD-levyille ja lainauksille
20. SQL-komentojen rakenne

Ennen siirtymistä itse SQL-komentoihin, esitellään SQL-lukuihin liittyvä tietokanta, sekä kerrataan lyhyesti miten SQL:ää käytetään ja mitä sillä voi tehdä. Lisäksi katsotaan, miten SQL:ää käytetään tämän kurssin puitteissa.
 

4.1 SQL-kieli, kertaus
SQL, eli Structured Query Language, on standardoitu ja relaatiotietokantojen tukema ohjelmointi/kyselykieli, jonka avulla voidaan tietokantoja luoda ja ylläpitää, sekä suorittaa tietokantaa vastaan moninaisia kyselyoperaatioita, joiden tarkoituksena on etsiä ja esittää tietokannassa olevaa tietoa. Kyselyiden avulla voidaan tietokannasta poimia esiin sen tauluihin tallennettua tietoa erilaisin kriteerein ja erilaisina yhdistelminä.
SQL ja relaatiomalli ovat vuosien varrella tiukasti nivoutuneet yhteen, ja siten on selvää että tietokantojen, tai ylipäätään tietojenkäsittelyn, kanssa tekemisissä oleville ainakin SQL:n perusteiden  ymmärtäminen on eduksi.
 

4.2 Tietokanta CD-levyille ja lainauksille
Alla on kuvattu SQL:n perusteiden läpikäyntiin käytettävän pienen esimerkkitietokannan rakenne ja sen taulujen sisältö. Tietokanta on kooltaan ja tietojen määrältään rajoitettu, ja näin ollen helpompi hahmottaa ja pitää mielessä.
Kolmesta taulusta koostuvassa tietokannassa on esitetty joitain perustietoja albumeittain / CD-levyttäin. Tämän ohella annetaan tietoja kavereista / lainaajista, sekä mikä albumi on milloinkin lainattu kenellekin. Tietokannan avulla päästään tutustumaan taulujen luomiseen, niiden attribuuttien muokkaamiseen, tietojen lisäämiseen, sekä tärkeimpiin kyselytekniikoihin. Tämän osion ohjelmointiharjoituksissa käytettävä tietokanta esitellään ensimmäisen harjoitustehtävän yhteydessä sekä erillisessä liitteessä.
Tietokannasta ei nähdä laajempia tietoja äänitteistä tai niihin liittyvistä asioista, eikä liioin lainauksien palautuksista tai muusta sellaisesta. Tällainen laajempi tietokanta esitellään luvussa 10.
4.2.1 TIETOKANNAN RAKENNE
Kolme taulua: Albumi, Lainaaja ja Lainaus.
Albumi ja Lainaaja -taulujen pääavaimet ovat AlbumiID ja vastaavasti LainaajaID; ne ovat tavallisia kokonaislukuja (integer). Lainaus-taululla on kaksoisavain, joka koostuu Albumi ja Lainaaja tauluista saatavista vierasavaimista. Näin lainaus yhdistyy aina tiettyyn lainaajaan ja tiettyyn albumiin. Rakenne on tuttu jo aiemmin nähdyistä yhteystauluista (M:N yhteyden purku yhteysyksilötyypillä), joista Lainaus toimii tässä jälleen yhtenä esimerkkinä.
 

Perusattribuuteista Albumi-taulussa ovat Nimi (Albumin nimi), Esittäjä (Albumin esittäjä eli artisti) ja Kesto (Äänitteen kokonaiskesto/-pituus) sekä Julkaistu (Albumin julkaisuvuosi.)
Pääavain AlbumiID on kokonaisluku. Nimi, Esittaja ja Kesto ovat merkkijonoja. Julkaistu on kokonaisluku.
Lainaus-taulussa on attribuutti Pvm (päivämäärä), eli lainauksen ajankohta. Se on tietotyypiltään Date eli päiväys.
Lainaaja-taulussa Etunimi ja Sukunimi antavat lainaajan nimen. PuhNro on puhelinnumero ja Email on lainaajan sähköpostiosoite. Attribuutit ovat merkkijonoja, lukuun ottamatta pääavainta, joka on kokonaisluku.
 

4.3 SQL-komentojen rakenne
Ohjelmointikielenä SQL on muotoilultaan varsin vapaa. Käyttäjä voi muotoilla SQL-lausekkeen varsin vapaasti käyttäen välilyöntejä, rivinvaihtoja ja lohkojen sisennyksiä. Huomioitavia vaatimuksia ovat lähinnä vain lausekkeen eri elementtien erotus pilkutuksella silloin kun se on tarpeen, lausekkeen päättäminen puolipisteeseen (kuten esim. useissa ohjelmointikielissä) sekä ns. varattujen sanojen tunnistaminen ja käytettävän TKHJ:n noudattamien nimeämiskäytäntöjen tunteminen.
Emme syvenny tässä syvällisesti SQL-lausekkeiden rakenteeseen - tämä onnistuu parhaiten itse SQL-teorialukujen avulla ja niihin liittyvien harjoitusten kautta, mutta esittelemme alla esimerkkilausekkeen, joka on laadittu tällä kurssilla noudatetun nimeämiskäytännön mukaisesti ja kerromme miten se toimii.
SQL-lause:
 
SELECT *
  FROM Lainaus
  WHERE Pvm < '2007-08-01';
 
Yllä nähdään tyypillinen SQL-kielinen lauseke. ISOILLA kirjaimilla on kirjoitettu ns. varatut sanat. Ne ovat SQL-kieleen kuuluvia komentoja, määritteitä tai funktioita (SELECT, WHERE, COUNT()...) jotka on määritetty kielen syntaksissa. Näitä sanoja ei normaalisti voi käyttää muuten kuin mitä SQL-syntaksi vaatii, eli ei esim. oman taulun nimenä. Siksi usein on tapana kirjoittaa ne isolla ja näin erottaa ne muista lausekkeen osista, ja kutsua niitä varatuiksi sanoiksi. Normaalisti TKHJ:n kannalta ei ole merkitystä kirjoitetaanko varatut sanat isoilla vain pienillä kirjaimilla. Siten select * from ... toimisi yhtälailla, kuten myös Select * From... On hyvä valita jokin nimeämiskäytäntö ja noudattaa sitä. Tällä kurssilla kirjoitetaan SQL:n varatut sanat aina isoilla.
Yllä nähdään sana "Lainaus", joka tässä tarkoittaa Lainaus-nimistä taulua. Aivan kuten SQL ei välitä oletusarvoisesti onko varatut sanat kirjoitettu pienellä vai isolla, ei se monissa järjestelmissä oletusarvoisesti myöskään välitä tietokannan taulujen ja niiden attribuuttien nimien kohdalla, kirjoitetaanko ne isoilla vai pienillä. Näin ollen lainaus, Lainaus ja LAINAUS tarkoittaisivat TKHJ:n näkökulmasta samaa taulua. Usein kuitenkin halutaan antaa taululle nimi, joka sisältää sekä suuria, että pieniä kirjaimia. Näin ovat taulujen nimet luettavampia erilaisissa listauksissa, jossa ne muuten saattavat oletusarvoisesti tulostua pelkästään pienillä tai suurilla kirjaimilla kirjoitettuna.
Näemme myös, että lauseke päättyy puolipisteeseen. Tämä on pakollista kaikkien SQL-lausekkeiden kohdalla. Mikäli puolipistettä ei kirjoiteta, ei lauseke pääty, eikä sitä aleta suorittamaan -- ja järjestelmä voi antaa virheilmoituksen tai yksinkertaisesti jäädä odottamaan, että lauseketta edelleen jatkettaisiin. Esimerkkilauseketta on myös jaoteltu rivinvaihdoilla osiin. tämä ei ole pakollista, ja SQL-lauseke voitaisiin kirjoittaa vaikka yhdelle riville. Toisaalta, FROM ja WHERE sanojen eteen on lisätty pari välilyöntiä. Näin on selkiytetty lausekkeen rakennetta muodostamalla näistä SELECT komentoon kuuluvista määritteistä ikään kuin sisennetty lohko niin että jokainen osanen on omalla rivillään. Kurssilla käytämme tämän tyylistä jäsennystä SQL-esimerkkien yhteydessä.
Parhaiten lausekkeiden muodostuksen oppii harjoitusten myötä ja esimerkkejä katsomalla.
 

4.3.1 SQL-HARJOITUSTEHTÄVÄT
Monivalintatehtävien rinnalle on tarjottu kaikkiin SQL-kieltä käsitteleviin lukuihin erityisiä ohjelmointitehtäviä, joissa opiskelijan tulee kys. luvun (ja aiemmin opitun) perusteella muodostaa tehtävän ratkaiseva SQL-lause. Opiskelijan antama vastaus suoritetaan tietokantaa vastaan, joka palauttaa virheilmoituksen, jos lause on väärin joko niin että se ei täytä tarkasti juuri pyydettyä tehtävänantoa, tai se sisältää syntaksivirheitä eikä siten ole kelvollinen SQL-lause. Kun oikea, tehtävän ratkaiseva SQL-lause on annettu, päästään etenemään seuraavaan harjoitukseen.
Selkeä ja helposti luettava nimeämistapa harjoitustehtäviin on: SQL:n varatut sanat ISOLLA, taulut ja attribuutit pienellä, kuten yllä ensimmäisessä esimerkissä.
5. Tietokannan luominen ja taulujen rakenne
21. Create database ja Create table perusteet
22. Create table ja vierasavain
23. Taulun rakenteen muokkaaminen
24. Taulun poistaminen

5.1 CREATE DATABASE ja CREATE TABLE -perusteet
Aloitamme SQL-kielen kanssa aivan alusta, eli miten uusi, tyhjä tietokanta luodaan SQL-kielen avulla. Kun tietokanta on olemassa, voidaan toteuttaa ennalta suunniteltu tietokantarakenne -- tähän tutustuimme luvussa 3. Rakenteen luomiseen tarvitaan perustiedot uusien taulujen ja niiden attribuuttien määrittämisestä. Jotta rakenne voidaan saattaa toimivaksi, tulee myös tietää miten vierasavaimet voidaan määritellä SQL-kielessä. Tämä nähdään seuraavassa kappaleessa. Lopulta myös katsomme, miten luodun taulun rakennetta voidaan vielä luomisvaiheen jälkeen tarvittaessa korjata.
 

5.1.1 CREATE DATABASE JA DROP DATABASE
SQL-kieli antaa mahdollisuuden luoda uusi, täysin tyhjä tietokanta, käyttämällä komentoa CREATE DATABASE. Yleensä myös käytettävä TKHJ voi luoda uusia tietokantoja, eikä tämän komennon käyttö ole välttämätöntä.
DROP DATABASE vastaavasti poistaa aiemmin luodun tietokannan. Myös tämä toiminto on usein mahdollista suorittaa suoraan TKHJ:n avulla.
Komentojen syntaksit:
	CREATE DATABASE [tietokannan_nimi]
	
	DROP DATABASE [tietokannan_nimi]
Esimerkki:
CREATE DATABASE CD_Tietokanta
 
DROP DATABASE CD_Tietokanta
Tulos:
Luodaan tyhjä tietokanta nimeltään CD_Tietokanta.
Poistetaan CD_Tietokanta.
 

5.1.2 CREATE TABLE
Jotta tietokantaan voidaan alkaa syöttämään tietoja, on ensin luotava tauluja ja määritettävä tarkkaan niille oikeanlaiset attribuutit sekä avainyhteydet. Kuten edellisessä osiossa nähtiin, tietokannan käsitekaavio tai siitä johdettu tarkka relaatiomallin kuvaus on tässä apuna. Itse tauluja määritettäessä ei enää pitäisi olla tarvetta pohtia mitään niiden rakenteeseen liittyviä kysymyksiä, vaan kaikki tulisi olla tarkkaan kirjattuna niin, että riittänee vain lukea suunnitelmasta mitä SQL-kielellä nyt tehdään.
Uusi taulu voidaan luoda komennolla CREATE TABLE.
Syntaksi:
	CREATE TABLE [taulun_nimi] (
	   [attribuutti1] [määreet],
	   [attribuutti2] [määreet],
	   ...
	   [attribuuttiN] [määreet]
	)
	 
Määreet ovat attribuuttikohtaisia. Määreitä ovat esimerkiksi attribuutin tietotyyppi ja asetus avainattribuutista.
Esimerkki:
CREATE TABLE Henkilo (
   HenkiloID     INTEGER      PRIMARY KEY,
   Etunimi       VARCHAR(32),
   Sukunimi      VARCHAR(64)
);
 
Tulos:
  Column   |         Type          | Modifiers
-----------+-----------------------+-----------
 HenkiloID | integer               | not null
 Etunimi   | character varying(32) |
 Sukunimi  | character varying(64) |
Indexes:
    "Henkilo_pkey" PRIMARY KEY, btree ("HenkiloID")
 
Luotiin taulu nimeltään Henkilo.
Luotiin tauluun kolme attribuuttia, joista HenkiloID määritettiin pääavaimeksi. Alempana nähdään lisää pää- ja vierasavaimista. HenkiloID:n tietotyyppi on "integer" eli kokonaisluku. Etunimi ja Sukunimi saavat tietotyypeikseen annetun maksimipituuden (32 ja 64) omaavat merkkijonot. Kukin attribuutti on erotettu pilkulla; määreet erotetaan attribuutin nimestä valinnaisella määrällä välilyöntejä.
Huomionarvoista on, että kullekin attribuutille on annettava tietotyyppi. Lista SQL standardin tukemista tietotyypeistä on nähtävissä liitteissä. Alla on listattu tavallisimpia.
 

5.1.3 TIETOTYYPPEJÄ
Tietotyyppi	Aliakset (vaihtoehtoinen nimi)	Kuvaus
boolean	bool	Boolean-arvo (tosi/epätosi)
character(x)	char(x)	Kiinteän pituinen merkkijono. (X = haluttu merkkien määrä)
character varying(x)	varchar(x)	Vaihtelevan pituinen merkkijono. (X = haluttu merkkien määrä)
date	 	Kalenteripäivä (vuosi, kuukausi, päivä)
integer	int, int4	4-tavuinen kokonaisluku
real	float4	4-tavuinen liukuluku
serial	serial4	Automaattisesti kasvava 4-tavuinen kokonaisluku
 

5.2 CREATE TABLE ja vierasavain
Kun tietokantaan tuodaan enemmän kuin yksi taulu, tarvitaan lähes aina vierasavainmäärityksiä. Luomme alla kuvatut kolme taulua ja niissä näkyvät avainyhteydet käyttämällä FOREIGN KEY -attribuuttimäärettä taulua luotaessa.
 
Kuva 1: Taulut ja avainyhteydet
 

 

5.2.1 FOREIGN KEY
Esimerkki:
CREATE TABLE Albumi (
   AlbumiID      INTEGER      PRIMARY KEY,
   Nimi          VARCHAR(32),
   Esittaja      VARCHAR(32),
   Kesto         VARCHAR(5),
   Julkaistu     INTEGER
);

CREATE TABLE Lainaaja (
   LainaajaID    INTEGER      PRIMARY KEY,
   Etunimi       VARCHAR(32),
   Sukunimi      VARCHAR(64),
   PuhNro        VARCHAR(15),
   Email         VARCHAR(32)
);

CREATE TABLE Lainaus (
   AlbumiID      INTEGER,
   LainaajaID    INTEGER,
   Pvm           DATE,
  
   PRIMARY KEY("AlbumiID", "LainaajaID"),

   FOREIGN KEY("AlbumiID") REFERENCES "Albumi"("AlbumiID"),
   FOREIGN KEY("LainaajaID") REFERENCES "Lainaaja"("LainaajaID")
);
 
Tulos:
Lainaus tauluun luotiin kaksoispääavain, joka koostuu AlbumiID ja LainaajaID attribuuteista. Samalla pääavaimen attribuutit merkittiin vierasavaimiksi FOREIGN KEY ja REFERENCES määritteillä.

Ohessa nähdään taulujen rakenteet:

Albumi

  Column   |         Type          | Modifiers
-----------+-----------------------+-----------
 AlbumiID  | integer               | not null
 Nimi      | character varying(32) |
 Esittaja  | character varying(32) |
 Kesto     | character varying(5)  |
 Julkaistu | integer               |
Indexes:
    "Albumi_pkey" PRIMARY KEY, btree ("AlbumiID")

Lainaus

   Column   |  Type   | Modifiers
------------+---------+-----------
 AlbumiID   | integer | not null
 LainaajaID | integer | not null
 Pvm        | date    |
Indexes:
    "Lainaus_pkey" PRIMARY KEY, btree ("AlbumiID", "LainaajaID")
Foreign-key constraints:
    "Lainaus_AlbumiID_fkey" FOREIGN KEY ("AlbumiID") REFERENCES "Albumi"("AlbumiID")
    "Lainaus_LainaajaID_fkey" FOREIGN KEY ("LainaajaID") REFERENCES "Lainaaja"("LainaajaID")

Lainaaja

   Column   |         Type          | Modifiers
------------+-----------------------+-----------
 LainaajaID | integer               | not null
 Etunimi    | character varying(32) |
 Sukunimi   | character varying(64) |
 PuhNro     | character varying(15) |
 Email      | character varying(32) |
Indexes:
    "Lainaaja_pkey" PRIMARY KEY, btree ("LainaajaID")


Päätelmiä
Yllä nähdään, miten pääavain voidaan määrittää myös attribuuttilistauksen jälkeen:
PRIMARY KEY(attribuutti1, attribuutti2)
Nyt attribuutti1 ja attribuutti2 muodostavat yhdessä pääavaimen, eli kaksoisavaimen, joka on tuttu relaatiomallin perusteista ja suunnitteluosiosta.
Vierasavain/-avaimet voidaan samoin määrittää attribuuttilistauksen jälkeen:
FOREIGN KEY(attribuutti) REFERENCES vieras_taulu(vierastaulun_jokin_attribuutti)
attribuutti merkitään nyt vierasavaimeksi vieras_taulu nimisestä toisesta taulusta löytyvään attribuuttiin, jonka nimi annetaan sulkeiden sisällä.
 

5.2.2 NOT NULL JA DEFAULT
Yllä nähtiin, että pääavainattribuutti sai lisämääreen NOT NULL. Tämä tarkoittaa, että attribuutin kentälle on aina annettava jokin arvo uutta tietuetta syötettäessä tai olemassa olevaa dataa päivitettäessä. Pääavaimelle tämä on itsestään selvää -- onhan pääavainarvo aina oltava. Tavallisille attribuuteille voidaan myös antaa vastaava NOT NULL määrite kun halutaan, että sen arvo on aina pakollinen. Tällöin TKHJ antaa virheen jos NOT NULL määritetylle attribuutille jätetään antamatta arvo.
Määritteellä DEFAULT voidaan asettaa attribuutille oletusarvo, joka annetaan jos attribuutin kentälle ei syötetä mitään arvoa. Alla on esimerkki, joka näyttää, miten näitä määreitä voidaan asettaa attribuuteille.
 
	CREATE TABLE Albumi (
	   AlbumiID      INTEGER      PRIMARY KEY,
	   Nimi          VARCHAR(32)  NOT NULL,
	   Esittaja      VARCHAR(32)  DEFAULT 'Ei esittäjää',
	   Kesto         VARCHAR(5),
	   Julkaistu     INTEGER
	);
 

5.3 Taulun rakenteen muokkaaminen
Taulun luomisen jälkeen voi tulla tarve muuttaa sen rakennetta esimerkiksi jonkin attribuutin osalta. Voidaan myös haluta poistaa jokin attribuutti, muuttaa taulun eheyssääntöjä, tai vaikkapa lisätä aivan uusia attribuutteja. Komennolla ALTER TABLE voidaan suorittaa nämä tehtävät.
 

5.3.1 ALTER TABLE
Esimerkki:
ALTER TABLE Henkilo
   ADD COLUMN Email VARCHAR(64);
 
Tulos:
Lisätään uusi attribuutti Email tauluun Henkilo. Samalla annetaan attribuutin tietotyyppi ja mahdolliset muut määreet, aivan kuten CREATE TABLE komennon yhteydessä.
 
Esimerkki:
ALTER TABLE Henkilo
   DROP COLUMN Email RESTRICT;
 
Tulos:
Poistetaan attribuutti taulusta Henkilo. Määre RESTRICT tarkoittaa, että poisto suoritetaan vain jos attribuuttiin ei liity minkäänlaisia viiteyhteyksiä. Toisin sanoen, ei voida vahingossa poistaa esimerkiksi vierasavainta. Määreellä CASCADE voidaan pakottaa poisto kaikissa olosuhteissa. Tällöin mahdolliset attribuuttiin liittyvät viite-eheydet, esim FOREGIN KEY määre, poistetaan myös.
 

5.4 Taulun poistaminen
Yhtälailla kuin käyttäjä voi luoda uusia tauluja SQL-kielen avulla, voidaan CREATE TABLE -komennolla luotu taulu myös poistaa. Tähän voi ilmetä tarvetta kun tietokanta kasvaa ja kehittyy, ja jokin taulu yksinkertaisesti jää turhaksi. Taulujen poistamiseen käytetään komentoa DROP TABLE.
 

5.4.1 DROP TABLE
Komento poistaa koko taulun tietokannasta, eli kaiken siihen tallennetun tiedon ja taulun rakenteen. Jos on tarpeen vain poistaa yksittäisiä tietueita, eikä koko taulua, on käytettävä seuraavassa luvussa esiteltävää DELETE komentoa.
Syntaksi:
	DROP TABLE [taulun_nimi] (RESTRICT | CASCADE)
	 
Määritteet RESTRICT ja CASCADE voidaan jättää pois; jos näin tehdään, noudattaa komento oletuksena RESTRICT määritettä. Vain toinen määritteistä voidaan kerrallaan sisällyttää DROP TABLE komentoon.
	RESTRICT määritettynä
	Taulu poistetaan vain, jos yksikään toinen taulu ei ole riippuvainen poistettavan taulun olemassaolosta. Poiston voi siis estää esimerkiksi se, että poistettavan taulun pääavain on vierasavainattribuuttina toisessa taulussa.
	CASCADE määritettynä
	Taulu poistetaan vaikka muilla tauluilla olisi siihen kohdistuvia riippuvuuksia. Olennaista on, että myös kaikki sellaiset taulut poistetaan, jotka ovat riippuvia CASCADE-määreellä poistettavasta taulusta. Tällaisille tauluille suoritetaan myös CASCADE-muotoinen poisto. Tuloksena komento voi parhaillaan poistaa lähes kaikki tietokannan taulut, ellei riippuvuuksia ole ensin purettu tai asetettu oikein. Sen kanssa on siis syytä olla varovainen!
 
Esimerkki: Yritetään poistaa ylempänä luotu Albumi taulu
DROP TABLE Albumi;

tai

DROP TABLE Albumi RESTRICT;
 
Tulos: Lainaus taulun riippuvuus Albumista (pää-vierasavainyhteys) estää poiston.
	
	NOTICE:  constraint Lainaus_AlbumiID_fkey on table "Lainaus" depends on table "Albumi"
	ERROR:  cannot drop table "Albumi" because other objects depend on it
	HINT:  Use DROP ... CASCADE to drop the dependent objects too.

 
Ratkaisuna olisi poistaa ensin Lainaus taulu ja sitten vasta Albumi taulu. Näin RESTRICT-muotoinen poisto onnistuisi. Vaihtoehtoisesti voidaan käyttää CASCADE-muotoista poistoa.
Esimerkki: CASCADE-määritteinen poisto
DROP TABLE Albumi CASCADE;
 
Tulos: Albumista riippuva Lainaus-taulu poistetaan myös.
6.1 - 6.2 Tiedon lisääminen
25. Tietueiden lisääminen tauluihin
26. Tietojen muuttaminen

6.1 Tietueiden lisääminen tauluihin
Kun taulun rakenne on määritetty, on se vielä tyhjä varsinaisista tietueista. Uusien tietueiden lisääminen tapahtuu SQL-komennolla INSERT INTO.
Esimerkeissä käytetään luvusta 4 tuttua Lainaukset tietokantaa.
 

6.1.1 INSERT INTO
Syntaksi:
	INSERT INTO [taulu] (attribuutit) VALUES (kenttien_arvot)
	Kursivoidut parametrit eivät ole pakollisia.
Esimerkki:
	Lisätään tietue, jonka kaikki kentät saavat arvon. Tällöin voidaan syntaksin ei-pakolliset parametrit jättää pois.
	INSERT INTO Lainaaja
	   VALUES (1, 'Esko', 'Tahvanainen', '0503787843', 'esko@email.com');
 
Tulos:
Lainaaja tauluun lisättiin yksi tietue. Ohessa taulun sisältö lisäyksen jälkeen.

 LainaajaID | Etunimi |  Sukunimi   |   PuhNro   |     Email
------------+---------+-------------+------------+----------------
          1 | Esko    | Tahvanainen | 0503787843 | esko@email.com
(1 row)
On tärkeää huomata, että kenttien arvot tulee antaa juuri siinä järjestyksessä kuin niitä vastaavat attribuutit on taulun rakennemäärittelyssä annettu. Lisäksi, mikäli kenttään yritetään syöttää sen tietotyypin kannalta sopimaton arvo, antaa TKHJ virheilmoituksen.
Kolmas huomioitava seikka on, että syötettäessä merkkijonoja, kirjoitetaan teksti '  ' merkkien sisään. Numeroarvot voidaan antaa sellaisenaan, kuten yllä luku 1. Mikäli attribuutin määritykset sallivat, voidaan kenttä jättää ilman arvoa syöttämällä arvoksi NULL
Esimerkki:
INSERT INTO Lainaaja
   VALUES (2, 'Satu', 'Tahvanainen', '0412211331', NULL);
 
Tulos:
 LainaajaID | Etunimi |  Sukunimi   |   PuhNro   |     Email
------------+---------+-------------+------------+----------------
          1 | Esko    | Tahvanainen | 0503787843 | esko@email.com
          2 | Satu    | Tahvanainen | 0412211331 |
(2 rows)
 

 
6.1.2 VAIHTOEHTOINEN INSERT INTO
INSERT INTO voi hyödyntää myös Syntaksi kohdassa annettua pidempää syntaksia, jolloin kenttien järjestys voi olla eri kuin taulun rakennemäärittelyssä. Kenttiä voidaan myös jättää tyhjiksi, mikä tulkitaan NULL arvon syöttämiseksi.
Esimerkki:
	Kenttien syöttöjärjestys voi nyt olla eri
	INSERT INTO Albumi (Nimi, AlbumiID, Esittaja, Julkaistu)
	   VALUES ('Valkoinen kupla', 6, 'Eppu Normaali', 1986);
 
Tulos:
Lisätyn Albumi tietueen Kesto sai arvon NULL, koska sille ei annettu lainkaan arvoa.

AlbumiID  |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        1 | Come Away With Me         | Norah Jones   | 45:11 |      2002
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
        3 | Talkie Walkie             | Air           | 43:27 |      2002
        4 | Playing the Angel         | Depeche Mode  | 52:23 |      2005
        5 | Mutter                    | Rammstein     | 45:11 |      2001
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
(6 rows)
 

6.1.3 DATE TIETOTYYPPI
Useissa tietokannanhallintajärjestelmissä SQL käyttää oletuksena kansainvälistä päivämäärän ISO standardia, joka on muotoa vvvv-kk-pp, esim. 2007-06-31. Date tietotyypin esitysmuoto voidaan tavallisesti vaihtaa lukuisiksi erilaisiksi, esimerkiksi eurooppalaiseen 31/6/2007 tai 31.6.2007 muotoon. Tässä yhteydessä käytetään oletusmuotoista date esitystä.
Esimerkki:
INSERT INTO Lainaus
   VALUES (1, 3, '2007-6-30');
 
Tulos:
AlbumiID | LainaajaID |    Pvm
----------+------------+------------
       1 |          3 | 2007-06-30
(1 row)

Edellä oleva INSERT INTO vaatii, että kyseiset uuden Lainaus tietueen vierasavainarvot löytyvät Albumi ja Lainaus tauluista, sillä vierasavain ei saa viitata arvoon jota ei ole olemassa. TKHJ tuottaa virheilmoituksen jos tällaisia arvoja yritetään syöttää.
 

6.2 Tietojen muuttaminen
Taulun tietueissa olevaa tietoa voi tulla tarpeen muuttaa. Tiedot muuttuvat, jolloin niitä on päivitettävä tietokantaan, tai on vahingossa syötetty virheellistä tietoa. UPDATE komennolla voidaan muuttaa yhden tai useamman tietueen kenttien arvoja.
 

6.2.1 UPDATE
Syntaksi:
	UPDATE [taulu] SET [attribuutti1 = uusi_arvo1, ... attribuuttiN = uusi_arvoN] WHERE [ehto]
		Where lauseke ei ole pakollinen
Esimerkki:
	Päivitetään Esko Tahvanaisen sähköpostiosoite. Ensimmäisessä emme muista emmekä aio katsoa mikä on kys. tietueen pääavainarvo, joten annamme päivitykselle ehdon, jossa kerromme halutun etu- ja sukunimiattribuuttien arvon. Näin löytyy haluttu tietue.
	Jälkimmäisessä viittaamme haluttuun tietueeseen suoraan sen pääavainarvolla.
	UPDATE Lainaaja
	   SET Email = 'esko.tahvanainen@email.com'
	   WHERE Etunimi = 'Esko' AND Sukunimi = 'Tahvanainen';
	
	
	UPDATE Lainaaja
	   SET Email = 'esko.tahvanainen@email.com'
	   WHERE LainaajaID = 1;
 
Tulos:
Sähköpostiosoite on päivitetty.

  LainaajaID | Etunimi |  Sukunimi   |   PuhNro   |            Email
------------+---------+-------------+------------+-----------------------------
          1 | Esko    | Tahvanainen | 0503787843 | esko.tahvanainen@email.com
          2 | Satu    | Tahvanainen | 0412211331 |
          3 | Matti   | Meikäläinen | 0401239876 | matti.meikalainen@sposti.fi
(3 rows)
On olennaista huomata, että WHERE kertoo MITKÄ tietueet muutetaan halutulla tavalla. Jos ehto annetaan huolimattomasti, voi olla että päivitys kohdistuu muihinkin tietueisiin tai ei-haluttuihin tietueisiin. Jos WHERE ehtona olisi yllä ollut pelkästään Sukunimi = 'Tahvanainen', olisi myös Satu Tahvanainen saanut kyseisen sähköpostiosoitteen. Toisaalta, näin myös voidaan kerralla päivittää useita tietueita samalla uudella attribuutin arvolla. Mikäli muutos halutaan kohdistaa kaikkiin tietueisiin, voidaan yksinkertaisesti jättää rajoittava WHERE ehtolauseke pois.
Kuten syntaksista nähdään, jos päivitetään kerralla useita attribuutteja, voidaan SET määreen jälkeen antaa pilkuilla erotettuna useampi kuin yksi Attribuutti = 'arvo' pari.
 

6.2.2 DELETE
Kun tarvitaan radikaalimpia muutoksia ja koko tietue on tarpeen poistaa, voidaan käyttää DELETE komentoa. Se on varsin suoraviivainen.
Syntaksi:
	DELETE FROM [taulu] WHERE [ehto]
Esimerkki:
	Poistetaan haluttu tietue asettamalla kohteen yksilöivä WHERE ehto kuten UDATEnkin kohdalla.
	DELETE FROM Henkilo
	   WHERE Etunimi = 'Esko' AND Sukunimi = 'Tahvanainen';
 
Kuten UPDATE komennonkin kohdalla, tulee varoa antamasta WHERE ehtoa joka valikoi muun tai muitakin tietueita kuin halutaan. Toisaalta, voidaan myös poistaa näin useita tietueita yhtäaikaa, kun laaditaan toivotut tietueet valikoiva ehto. Antamalla ehto WHERE Sukunimi = 'Tahvanainen' voitaisiin poistaa kaikki Tahvanaiset.
 
7. Tiedon haku: SELECT ja WHERE
27. SQL ja SELECT kyselyjen muodostaminen
28. SELECT, WHERE ja vertailuoperaattorit
29. WHERE + AND / OR

7.1 SQL ja SELECT kyselyjen muodostaminen
Tähän mennessä on nähty miten relaatiotietokanta voidaan suunnitella ja toisaalta toteuttaa SQL-kielen avulla. Yleisin tapa käyttää SQL-kieltä on kuitenkin tiedon haku jo olemassa olevasta tietokannasta -- eli vastata siihen tarkoitukseen jota varten on nähty kaikki se vaiva suunnittelun ja toteutuksen suhteen. Tässä luvussa käydään läpi tiedon haun, eli kyselyiden, perusmenetelmiä. SELECT-komento yhdessä WHERE-lausekkeiden kanssa muodostaa SQL:n perustyökalun kyselyiden laatimiseen.
 

7.1.1 SELECT ILMAN WHERE LAUSEKETTA
Syntaksi:
	SELECT [attribuutti1, attribuutti2, ..., attribuuttiN] FROM [taulu1, taulu2, ..., tauluN]
Esimerkki:
	Haetaan attribuutin Nimi arvot taulusta Albumi.
	SELECT Nimi FROM Albumi;
 
Tulos:
           Nimi
---------------------------
 Come Away With Me
 Talkie Walkie
 Playing the Angel
 Mutter
 The Dark Side of the Moon
 Valkoinen kupla
(6 rows)
SELECT hakee kaikista tietueista pyydetyn attribuutin arvon.
Attribuutteja voidaan listata useampia:
Esimerkki:
SELECT Nimi, Esittaja FROM Albumi;
 
Tulos:
           Nimi            |   Esittaja
---------------------------+---------------
 Come Away With Me         | Norah Jones
 Talkie Walkie             | Air
 Playing the Angel         | Depeche Mode
 Mutter                    | Rammstein
 The Dark Side of the Moon | Pink Floyd
 Valkoinen kupla           | Eppu Normaali
(6 rows)
 
Voidaan myös käyttää *-merkkiä jos halutaan listattavaksi kaikki attribuutit:
Esimerkki:
SELECT * FROM Albumi;
 
Tulos:
  AlbumiID |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        1 | Come Away With Me         | Norah Jones   | 45:11 |      2002
        3 | Talkie Walkie             | Air           | 43:27 |      2002
        4 | Playing the Angel         | Depeche Mode  | 52:23 |      2005
        5 | Mutter                    | Rammstein     | 45:11 |      2001
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
(6 rows)
 

 
7.2 SELECT, WHERE ja vertailuoperaattorit
Kyselyjä voidaan tarkentaa ja monipuolistaa WHERE-lausekkeen avulla. WHERE tavattiin jo esimerkiksi UPDATE-komennon yhteydessä, eikä sen käyttö eroa näiden eri komentojen välille. Tässä esitetyt WHERE:n käyttömenetelmät soveltuvat siis UPDATE, DELETE ja kaikkien muiden komentojen yhteyteen jotka voivat hyödyntää WHERE-lauseketta.
 

7.2.1 VERTAILUOPERAATTORIT
OPERAATTORI	SELITE
=	yhtäsuuri kuin
>	suurempi kuin
<	pienempi kuin
>=	suurempi tai yhtäsuuri kuin
<=	pienempi tai yhtäsuuri kuin
<>	erisuuri kuin
 
7.2.2 SELECT + WHERE
Syntaksi:
	SELECT [attribuutit] FROM [taulut] WHERE [ehto]
	Vertailuoperaattorit ovat käytössä [ehto] lausekkeessa.
Esimerkki:
	Haetaan Lainaaja-tietueet joissa sukunimi on Tahvanainen. Pyydetään tietueiden kaikki attribuutit (*)
	SELECT * FROM Lainaaja
	   WHERE Sukunimi = 'Tahvanainen';
 
Tulos:
LainaajaID  | Etunimi |  Sukunimi   |   PuhNro   |           Email
------------+---------+-------------+------------+----------------------------
          2 | Satu    | Tahvanainen | 0412211331 |
          1 | Esko    | Tahvanainen | 0503787843 | esko.tahvanainen@email.com
(2 rows)
 
Esimerkki:
	Haetaan lainaukset, joissa päivämäärä on aiempi kuin 1.8.2007
	SELECT *
	FROM Lainaus
	WHERE Pvm < '2007-08-01';
 
Tulos:
  AlbumiID | LainaajaID |    Pvm
----------+------------+------------
        1 |          3 | 2007-06-30
(1 row)
 

7.2.3 LASKUTOIMITUS WHERE EHTONA
WHERE lauseiden tehoa voidaan edelleen kasvattaa käyttämällä matemaattisia perusoperaattoreita ehtolauseessa. Operaattorit ovat:
•  +  Yhteenlasku
•  -  Vähennyslasku
•  *  Kertolasku
•  /  Jakolasku
•  %  Jakojäännös

Esimerkki:
	Haetaan albumit jotka on julkaistu yli kymmenen vuotta sitten (nyt: 2007)
	SELECT *
	FROM Albumi
	WHERE (2007 - Julkaistu) >= 10;
 
Tulos:
AlbumiID  |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
(2 rows)
 

7.3 WHERE + AND / OR
SELECT-komennon WHERE-lauseketta voidaan monipuolistaa edelleen käyttämällä AND ja OR -operaattoreita. Näin voidaan kyselyyn ottaa mukaan enemmän kuin yksi ehto. Esimerkiksi kysely "Hae albumit joissa esittäjä on Eppu Normaali ja joiden julkaisuvuosi on aiempi kuin 1989" sisältää kaksi ehtoa, jotka on erotettu "ja" sanalla. Tällöin kyselyn ehdossa voidaan ottaa avuksi AND-operaattori ja ehto on voimassa vain tietueille jotka täyttävät molemmat ehdot. OR-operaattoria käytettäessä ehto on tosi kaikille tietueille joille edes toinen operandeista on tosi.
 

7.3.1 AND
AND voidaan sijoittaa niiden ehtojen väliin, joiden halutaan olevan yhtäaikaa voimassa. Ehdot voidaan kirjoittaa sulkeiden sisään, tai sulkeet voidaan yhtälailla jättää pois, kuten alla.
 
Esimerkki:
	Haetaan albumit, jotka on julkaistu vuosien 1980 ja 2002 välillä. Asetetaan kaksi ehtoa: Jälkeen tai tasan 980, sekä ennen tai tasan 2002. Ehdot sidotaan AND-operaattorilla, ja nyt molempien on oltava tosia.
	SELECT * FROM Albumi
	   WHERE Julkaistu >= 1980 AND Julkaistu <= 2002;
 
Tulos:
AlbumiID  |       Nimi        |   Esittaja    | Kesto | Julkaistu
----------+-------------------+---------------+-------+-----------
        1 | Come Away With Me | Norah Jones   | 45:11 |      2002
        3 | Talkie Walkie     | Air           | 43:27 |      2002
        5 | Mutter            | Rammstein     | 45:11 |      2001
        6 | Valkoinen kupla   | Eppu Normaali |       |      1986
(4 rows)
 
Esimerkki:
	Ehtoja voi olla useampia: Tarkennetaan hakua edelleen asettamalla kolmas ehto ja lisäämällä toinen AND operaattori.
	SELECT * FROM Albumi
	   WHERE Julkaistu >= 1980 AND Julkaistu <= 2002 AND Esittaja = 'Eppu Normaali'
 
Tulos:
  AlbumiID |      Nimi       |   Esittaja    | Kesto | Julkaistu
----------+-----------------+---------------+-------+-----------
        6 | Valkoinen kupla | Eppu Normaali |       |      1986
(1 row)
 

7.3.2 OR
Kun riittää, että vain toinen tai yksi listatuista ehdoista on tosi, voidaan ne yhdistää OR-operaattorilla. Sitä voidaan käyttää myös tilanteissa, joissa on etsittävä tietueita useilla ehdoilla, ja jolloin AND-operaattorin käyttö kävisi hankalaksi tai olisi muodostettava useita erillisiä kyselyitä. Esimerkiksi, jos tulisi hakea albumeita vuosilta 1986, 2001 ja 2002, voitaisiin laatia kolme kyselyä, joista kukin hakee halutun vuoden albumit. Helpointa on kuitenkin laatia yksi kysely ja käyttää OR-operaattoria, kuten alla.
 
Esimerkki:
	Haetaan albumeja kolmelta eri vuodelta. Vuosi on siten X TAI Y TAI Z.
	SELECT * FROM Albumi
	   WHERE Julkaistu = 1986 OR Julkaistu = 2001 OR Julkaistu = 2002;
 
Tulos:
AlbumiID |       Nimi        |   Esittaja    | Kesto | Julkaistu
----------+-------------------+---------------+-------+-----------
        1 | Come Away With Me | Norah Jones   | 45:11 |      2002
        3 | Talkie Walkie     | Air           | 43:27 |      2002
        5 | Mutter            | Rammstein     | 45:11 |      2001
        6 | Valkoinen kupla   | Eppu Normaali |       |      1986
(4 rows)


7.3.3 AND + OR
AND ja OR antavat jo erikseen mahdollisuuden laatia monipuolisia kyselyjä. Kuten arvat saattaa, voidaan niitä hyvin käyttää myös yhdessä hakuehdon hienosäätöön. Tällöin voi olla hyvä käyttää sulkeita, kuten alla on tehty, selkiyttämään ehtolauseketta.
 
Esimerkki:
	Haetaan 2000-luvulla julkaistut albumit kahdelta eri esittäjältä. Ehto "julkaisuvuosi >= 2000" on oltava totta aina, joten käytämme AND-operaattoria. Kelvollisessa tietueessa Esittajan on oltava toinen halutuista, joten niiden väliin on asetettava OR.
	SELECT Esittaja, Julkaistu FROM Albumi
	   WHERE (Esittaja = 'Eppu Normaali' OR Esittaja = 'Norah Jones') AND Julkaistu >= 2000;
 
Tulos:
  Esittaja   | Julkaistu
-------------+-----------
 Norah Jones |      2002
(1 row)


 
8. Tulosten järjestelyä
30. ORDER BY lauseet
31. DISTINCT ja COUNT

8.1 ORDER BY -lauseet
Hyvin laadittu SQL kysely paitsi löytää juuri halutut tiedot, myös esittää ne halutulla tavalla. ORDER BY -lausekkeella voidaan vaikuttaa, miten kyselyn tulokset listataan. Voidaan esimerkiksi haluta tuloste aakkosjärjestyksessä, tai nousevassa tai laskevassa järjestyksessä. Toisaalta, voi olla tarpeen listata taulun kaikki tiedot juuri tietyn attribuutin mukaisesti järjestettynä.
Tässä luvussa käydään läpi ORDER BY sekä lausekkeet DISTINCT ja COUNT sen lisänä.
 

8.1.1 ORDER BY
Esimerkki:
	Taulun sisällön tulostaminen ilman ORDER BY -lauseketta. Tulostusjärjestys voi olla mikä vain, riippuen siitä miten TKHJ sattuu säilyttämään tietueita levyllä.
	SELECT * FROM Albumi;
 
Tulos:
AlbumiID  |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        1 | Come Away With Me         | Norah Jones   | 45:11 |      2002
        3 | Talkie Walkie             | Air           | 43:27 |      2002
        4 | Playing the Angel         | Depeche Mode  | 52:23 |      2005
        5 | Mutter                    | Rammstein     | 45:11 |      2001
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
(6 rows)

Listaus ei ole missään loogisessa järjestyksessä. Tämä johtuu siitä, että tietueita on manipuloitu eri tavoin. Samalla niiden järjestys pääavainarvoon nähden on muuttunut.

Esimerkki:
	Käytetään ORDER BY -lauseketta, ja pyydetään listaus halutun attribuutin mukaan.
	SELECT * FROM Albumi
	   ORDER BY AlbumiID;
 
Tulos:
AlbumiID  |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        1 | Come Away With Me         | Norah Jones   | 45:11 |      2002
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
        3 | Talkie Walkie             | Air           | 43:27 |      2002
        4 | Playing the Angel         | Depeche Mode  | 52:23 |      2005
        5 | Mutter                    | Rammstein     | 45:11 |      2001
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
(6 rows)

Listaus on nyt järjestetty AlbumiID:n mukaan.


Voidaan antaa ORDER BY:lle mikä vain attribuutti, esim. "Julkaistu". Tällöin listaus järjestyy halutun attribuutin mukaan. Julkaisuvuoden kohdalla kasvavassa järjestyksessä niin, että AlbumiID 2 (1973) olisi ensimmäinen ja toisaalta AlbumiID 4 (2005) viimeisenä listassa. Lausekkeen syntaksi vaatii ainoastaan, että ainakin yksi järjestettävä attribuutti on nimettävä. Toisaalta, järjestettäviä kohteita voi myös olla useampia (kts. 8.1.3).
Oletusjärjestys listauksessa on aina nouseva: Pienin lukuarvo ensin, suurin viimeisenä; merkkijonoissa normaali aakkosjärjestys.
Jos on tarpeen vaihtaa listaus laskevaksi, voidaan se tehdä DESC määreellä.
 

8.1.2 ORDER BY + DESC
Esimerkki:
	Listataan Albumi-taulu julkaisuvuoden mukaan, uudemmasta vanhempaan. Oletuksenahan pienin lukuarvo tulisi ensin -- nousevan järjestyksen mukaisesti -- joten on määrättävä DESC lausekkeella laskeva järjestys.
	SELECT * FROM Albumi
	   ORDER BY Julkaistu DESC;
 
Tulos:
AlbumiID  |           Nimi            |   Esittaja    | Kesto | Julkaistu
----------+---------------------------+---------------+-------+-----------
        4 | Playing the Angel         | Depeche Mode  | 52:23 |      2005
        1 | Come Away With Me         | Norah Jones   | 45:11 |      2002
        3 | Talkie Walkie             | Air           | 43:27 |      2002
        5 | Mutter                    | Rammstein     | 45:11 |      2001
        6 | Valkoinen kupla           | Eppu Normaali |       |      1986
        2 | The Dark Side of the Moon | Pink Floyd    | 43:00 |      1973
(6 rows)
 

8.1.3 JÄRJESTYS USEAN ATTRIBUUTIN MUKAAN
Vastaan voi tulla tilanne, jossa esimerkiksi henkilöitä järjestetään nimen perusteella ja henkilöitä on useita. Samalla sukunimellä voi tällöin olla useita tietueita. Jotta listaus olisi hyödyllinen, tulee tällöin järjestää saman sukunimen omaavat edelleen etunimen mukaisesti.
ORDER BY:llä tämä onnistuu ottamalla lausekkeeseen kaikki attribuutit joiden mukaan halutaan järjestää. Attribuuttien kirjoitusjärjestys kertoo luokittelujärjestyksen. Asian havainnollistamiseksi annetaan esimerkki.
Esimerkki:
	Listataan Lainaajien nimet. Pyydetään järjestämään ENSIN sukunimen mukaan laskevassa järjestyksessä. Mikäli samaa sukunimeä esiintyy useampia, järjestetään ne edelleen etunimen mukaan, myös laskevassa järjestyksessä.
	SELECT Sukunimi, Etunimi FROM Lainaaja
	   ORDER BY Sukunimi DESC, Etunimi DESC;
 
Tulos:
  Sukunimi   | Etunimi
-------------+---------
 Tahvanainen | Satu
 Tahvanainen | Esko
 Meikäläinen | Matti
 Meikäläinen | Maija
(4 rows)


 
8.2 DISTINCT ja COUNT
Kun tietokannassa alkaa olla enemmän tietoa, tuottavat useat kyselyt toistuvia arvoja. Pyydettäessä listaamaan Albumit taulun kaikki yhtyeet/esittäjät, voidaan saada lista jossa sama artisti esiintyy useita kertoja peräkkäin, koska häneltä on tallennettu useita albumeja tauluun. Laajassa tietokannassa tämä ei enää tuota hyödyllistä tulosta. Jos halutaan välttää toistuvien arvojen listaaminen, voidaan käyttää DISTINCT-lauseketta. Se toimii hyvin yhteen myös ORDER BY -lausekkeen kanssa.
COUNT-funktiolla voidaan esittää, kuinka monta kertaa jokin tietue tai tietyn arvon omaava attribuutti esiintyy. Voidaan siten pyytää esittämään kuinka monta albumia kaiken kaikkiaan taulussa on, tai vaikkapa miten monta albumia yhtyeeltä X löytyy.
 

8.2.1 ORDER BY + DISTINCT
Esimerkki:
	Tulostetaan ensin ilman ORDER BY tai DISTINCT -lauseketta artistit.
	SELECT Esittaja FROM Albumi;
 
Tulos:
   Esittaja
---------------
 Norah Jones
 Air
 Depeche Mode
 Rammstein
 Pink Floyd
 Eppu Normaali
 CMX
 Pink Floyd
 CMX
 The Beatles
 The Beatles
 The Beatles
(12 rows)

Esittaja esiintyy yhtä useasti kuin häneltä
on albumi eli tietue taulussa.

Esimerkki:
	Käytetään DISTINCT -lauseketta ja pyydetään näin esittämään kukin löytynyt arvo vain kerran. Lisäksi pyydetään jo opitulla tavalla aakkostettu listaus Albumin mukaan käyttämäällä ORDER BY:tä.
	SELECT DISTINCT Esittaja
	   FROM Albumi
	   ORDER BY Esittaja;
 
Tulos:
   Esittaja
---------------
 Air
 CMX
 Depeche Mode
 Eppu Normaali
 Norah Jones
 Pink Floyd
 Rammstein
 The Beatles
(8 rows)


8.2.2 COUNT
Esimerkki:
	Kuinka monta albumia taulussa on?
	SELECT COUNT(*) FROM Albumi;
 
Tulos:
count
-------
    12
(1 row)

count = 12 --> 12 albumia.
 
Esimerkki:
	Kuinka monta albumia taulussa on artistilta "The Beatles"?
	SELECT COUNT(*)
	   FROM Albumi
	   WHERE Esittaja = 'The Beatles';
 
Tulos: 3kpl
count
-------
     3
(1 row)
 
WHERE toimii tässä kuten on nähty aiemmin, ja siten COUNT voidaan kohdistaa hyvin monimutkaistenkin ehtojen avulla, esim. yhdistelemällä AND ja OR -operaattoreita jo opitulla tavalla.
9. Lisää relaatiomallista
32. Avainehdokkaat
33. Tietokannan eheys
34. Lisää eheyssäännöistä
35. Tietokannan rakenteeseen liittyvät ongelmat
36. Avainyhteys: Linkki vai jotain muuta?
37. Keskeisiä termejä suomeksi ja englanniksi

9.1 Avainehdokkaat
Tähän mennessä on nähty miten relaatiomallissa kullekin taululle määritellään sen tietueet yksilöivä pääavain, ja toisaalta, miten pää- ja vierasavainattribuuteilla voidaan luoda taulujen välille yhteyksiä ja näin "linkittää" tietoa relaatioiden kesken.
Relaatiomalli tuntee kuitenkin vielä kolmannen avaintyypiin, avainehdokkaan. Käymme tässä läpi mitä avainehdokkaat ovat ja mikä merkitys niillä on tietokannan rakenteen kannalta. Avainehdokkaat, ja avaimet yleensäkin, liittyvät läheisesti relaatioiden eheyteen ja eheyssääntöihin, joita käsitellään tämän jälkeen.
 

 
9.1.1 PÄÄAVAIMEN VALINTA JA AVAINEHDOKKAAT
Relaatiomalli tuntee kolmannen avaintyypin, avainehdokkaan. Avainehdokas on sellainen attribuutti tai attribuuttikokoelma, josta voisi tulla taululle pääavain. Eli avainehdokas on kykenevä yksilöimään jokaisen taulun tietueen.
Päätettäessä pääavaimesta, tulisi taulun kaikki avainehdokkaat etsiä ja listata. Kun tietokanta luodaan käsiteanalyysin kautta laatimalla käsitekaavio, suoritetaan tämä yhteystyyppien ja ominaisuustyyppien etsimisen jälkeen. Käsitekaavion yhteydessä puhutaan joskus myös toisioavaimista viitattaessa avainehdokkaisiin. Pääavain valitaan avainehdokkaiden joukosta, jos niitä on enemmän kuin yksi. Jos yhtäkään avainehdokasta ei jostain syystä löydy, on sellainen luotava.
Kun taulun pääavain on valittu, merkitään se pääavaimeksi. Relaatiomallin näkökulmasta kaikki avainehdokkaat ovat ja pysyvät avainehdokkaina, myös pääavain: Pääavain on lisämääre joka annetaan tietylle avainehdokkaalle. Kaikki avainehdokkaat säilyttävät statuksensa.
 

9.1.2 KUN PÄÄAVAIN ON VALITTU
Mikä on avainehdokkaiden merkitys pääavaimen nimeämisen jälkeen? On sanottu, että on suositeltavaa tuoda vierasavaimeksi ainoastaan toisen taulun pääavain. Tähän myös päädytään, jos rakenne luodaan käsitemallin avulla. Se on kuitenkin vain käsiteanalyysin ominaisuus -- ominaisuus joka monesti nähdään hyvänä. Tosiasiassa relaatiomalli sallii vierasavaimen viittaavaan mihinkä tahansa avainehdokkaaseen, ei pelkästään pääavaimeen.
Voimme siis todeta, että vierasavain voi olla toisen taulun avainehdokas. Avainehdokas taas voi olla pääavain, joka on aina yksi avainehdokkaista. Joskin mahdollista, yleensä ei suositella avainyhteyden luomista muuhun kuin pääavaimeen, sillä siihen ei normaalisti pitäisi olla väistämätöntä tarvetta, ja toisaalta, tietokannan tehokkaan rakenteen säilyttämisen kannalta voi olla haitallista jos luodaan useita ei-pääavain yhteyksiä. Se voi olla myös merkki yhteystyyppien puutteellisesta analysoinnista suunnitteluvaiheessa.
Alla on esitetty yksittäinen taulu, jolle nimetään kaikki löytyvät avainehdokkaat (2kpl) ja lopulta valitaan pääavain. Toinen avainehdokas koostuu kahdesta attribuutista.
 
Kuva 1: Taululle nimetään avainehdokkaat ja valitaan tämän jälkeen pääavain.
 

 

9.2 Tietokannan eheys
Aiemmin on jo viitattu relaatiomallista ja suunnittelusta puhuttaessa tietokannan eheyteen ja eheyssääntöihin. Eheys (integrity) voidaan ymmärtää monella tasolla ja lukuisilla eri tavoilla. Voidaan puhua käyttäjän määrittämistä konkreettisista eheyssäännöistä, jotka voivat olla integroitu suoraan tietokannan rakenteeseen (taluihin tai yksittäisiin attribuutteihin); toisaalta, avainyhteydet luovat väistämättä omanlaisiaan, osin tai kokonaan käyttäjästä riippumaatomasti pakokottavia eheysvaateita, joihin on jo tutustuttukin. Yhtälailla jo pelkkä taulun luominen muodostaa väistämättä eheyspakotteita, jotka eivät ole käyttäjän päätettävissä, niiden liittyessä läheisesti relaatiomallin toimintaperiaatteeseen.
 

 
9.2.1 KÄYTTÄJÄN MÄÄRITTÄMÄT EHEYSSÄÄNNÖT
Tässä yhteydessä esitetään eheyssääntöjä yleisellä tasolla. Tarkkojen ja monimutkaisten, esimerkiksi tietotyyppikohtaisten, eheyssääntöjen määrittäminen voi erota paljonkin eri TKHJ:ien välillä, ja niiden kyky käyttää eri asteisia eheysmääreitä voi vaihdella suuresti. SQL-kieli tarjoaa joitain standardoituja välineitä eheysmääreiden luomiseen, mutta näiden päälle voi olla saatavailla runsaasti erinäisiä valmistajakohtaisia laajennuksia. Tässä suhteessa on käyttäjän hyvä tutustua käytetyn järjestelmän ominaisuuksiin ja sen tarjoamiin mahdollisuuksiin.
Tietokannassa voi periaatteessa olla ääretön määrä käyttäjän luomia eheyssääntöjä, eikä pitäisi olla mitään tiukkaa rajaa miten monipuolinen tai laaja jokin eheyssääntö on. Käytännössä käyttäjän itse luomia eheysmääreitä voidaan ajatella neljällä tasolla:
• Tietotyyppikohtaiset,
• koko tietokannan laajuiset,
• taulukohtaiset, ja
• attribuuttikohtaiset eheyssäännöt
 

9.2.2 TIETOTYYPIN EHEYSSÄÄNNÖT
Tarkastellaan alla olevaa taulua:
	
	TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
	1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
	2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
	3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
	4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
	5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
	6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
	7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
Kuten jo tiedetään, on jokaiselle attribuutille annettu tietotyyppi. Standardeja tietotyyppejä olivat mm. kokonaisluku, merkkijono, päivämäärä jne. Puhuttaessa tietoyyppikohtaisista eheyssäännöistä, tarkoitetaan: Mitkä ovat laillisia arvoja tälle tietotyypille; eli syötettäessä tyypin X mukaisia arvoja, mitä ne saavat ja eivät saa olla. Tällainen määrittely voi tuntua erikoiselta vaikkapa kokonaisluvulle: Standardi kertoo, miten kyseinen tietotyyppi on määritetty. Tämä on totta. Mutta relaatiomalli mahdollistaa käyttäjän itse luoda uusia tietotyyppejä.
9.2.3 KÄYTTÄJÄN OMAT TIETOTYYPIT
Yllä olevan taulun sisältävässä tietokannassa voisi olla määritetty uusi tietotyyppi Toimipaikka. Taulun vierasavain ToimipaikkaID ja kys. pääavaimen omaava Toimipaikka taulu määrittäisivät ToimipaikkaID:n olemaan -- ei merkkijonotyyppinen -- vaan Toimipaikka tietotyyppinen. Samoin Nimi voisi olla tietotyypiltään Nimi eikä "VARCHAR(60)".
Käyttäjän luoma tietotyyppi määritetään relaatiomallin perustietotyypin kautta. Esimerkiksi Nimi olisi tällöin perustyyppi merkkijono plus mahdollsiia lisämääreitä. Tuloksena uusi tietotyyppi, joka olisi aina merkkijono, ja joka käyttäytyisi kokolailla samoin kuin esim. "VARCHAR(60)."
Käyttäjän tietotyyppi voi poiketa paljon tai vähän perustietotyypistä -- joskus vain nimensä puolesta: Halutaan, että kaikki puhelinnumerot ovat tietotyyppiä PuhNro. Määritetään PuhNro tietynlaiseksi merkkijonoksi ja sillä selvä. Helppo muistaa, helppo käyttää.
9.2.4 TIETOTYYPIN EHEYS
Tietoyyypin eheyssäännöt määräävät siis mitä arvoja tietotyyppi voi esittää. Tämä tuntuu jo järkevämmältä itse luotujen tietotyyppien kohdalla. On mahdollista, että Nimi ei voisi sisältää esim. numeroita tai eksoottisia ASCII-koodeja. Toisaalta, TyontekijaID voisi sisältää vain positiivisia lukuarvoja, jotka olisivat vain parillisia ja aina suurempia kuin 100 (102, 104, 106..) mutta eivät suurempia kuin 1000. jne.
Nyt jokainen attribuutti, joka luotaisiin tämän tietotyypin mukaiseksi, noudattaisi näitä sääntöjä. Annettessa virheellinen arvo seuraisi samanlainen virheilomoitus kuin jos esimerkiksi koitettaisiin antaa laiton DATE muotoa oleva päivämäärä attribuutille jonka tietytyyppi on DATE.
 

9.3 Lisää eheyssäännöistä
9.3.1 ATTRIBUUTTI- JA TAULUKOHTAISET EHEYSSÄÄNNÖT
Attribuutin eheys ymmärretään usein tarkoittavan yksinkertaisesti, että attribuutti on sidottu johonkin tietotyyppiin. Yleensä tämä on käyttäjän kannalta itsestäänselvää, sillä TKHJ vaatii uutta taulua luotaessa tai olemassaolevaa muokattaessa, että jokaisella attribuutilla on märitettynä tietotyyppi -- itse luotu tai jokin perustyypeistä.
Taulukohtaiset eheyssäännöt voivat sen sijaan olla hyvinkin mielenkiintoisia. Käsiteanalyysin yhteydessä kirjattavilla eheysvaatimuksilla voi olla merkittävä rooli juuri yksittäisen taulun kannalta, ja taulu voi olla tyypillisten lisäys- poisto ja muokkaussääntöjen kohde. Esimerkiksi taululle Opiskelija voitaisiin asettaa seuraavia eheysvaateita:
 
 Mahdollisia eheyssääntöjä:
• Jokaiselle tietueelle on aina oltava syötettynä arvot attribuuteille OpiskelijaNro (pääavain), Etunimi ja Sukunimi.
• Opiskelijalle, jolle on merkitty arvo TOSI kohtaan Vierailija, voidaan antaa vain 9 numeroa pitkä Opiskeijanumero jonka on alettava numeroilla "109".
• Jos Kotimaa attribuutti on muu kuin Suomi, on attribuutille Äidinkieli annettava arvo.
• Jos opiskelijan aloitusvuosi on suurempi kuin 2005, on opiskelijanumero 10-numeroinen.
• jne...
 
Nähdään, että osa taulukohtaisista eheyssäännöistä saattaa olla toteutettavissa yksinkertaisestikin jo pelkällä NOT NULL -määrellä attribuutin tietotyypin yhteydessä tai mekritsemällä attribuutti avaimeksi. Toiset voivat vaatia monimutkaisia eheyssääsääntöjä joiden suunnittelu voi vaatia harkintaa.
 

 
9.3.2 TIETOKANTALAAJUISET EHEYSSÄÄNNÖT
Kun eheysvaatimus kohdistuu yksittäisen taulun, attribuutin tai tieotyypin sijasta taulujen väliseen vuorovaikutukseen,, voidaan sen katsoa olevan tietokannan laajuinen. Tällaiset eheysvaatimukset tulisi määrittää käsiteanalyysin yhteydessä.
Esimerkkinä voisi olla edelleen yliopsiton opiskelijatietokanta
 Mahdollisia eheyssääntöjä:
• Tauluun "IlmoittauminenKurssille" voidaan lisätä tietue taulusta Opiskelija vain jos kys. opiskelijalla on merkintä OpiskelijanSuoritukset taulussa kys. kurssin esitietokursseille.
• Kurssiin, jonka status on "Aktiivinen", on aina liityttävä Vastuuhenkilö.
• Kurssin Esitieto voi viitata vain olemassaolevaan Kurssiin.
• Poistettaessa Opiskelija on poistettava kaikki tähän liittyvät Ilmoittaumiset ja Suoritustiedot.
• jne...
 
Osa tietokannan laajuisista eheyssäännöistä syntyy automaattisesti avainyhteyksien kautta. Tällöinkin voi olla tarpeen asettaa lisämääreitä esimerkiksi poistojen ja lisäysten suhteen. Tämä on hyvin TKHJ kohtaista.
 

9.4 Tietokannan rakenteeseen liittyvät ongelmat
Avainyhteyksien ja eheyssääntöjen ohella voi relaatitoietokannan rakenteessa tulla vastaan joitain käytännön ongelmia, jotka vaikeuttavat tietokannan käyttöä, tai jopa mahdollistavat virheellisen tiedon syöttämisen tai päivittämättömien tietojen jäämisen tietokantaan. Rakenteessa voi olla piirteitä, joita relaatiomalli suoranaisesti ei kiellä tai TKHJ estä, mutta jotka eivät ole relaatiomallin toimintatavan mukaisia ja jotka voivat siten altistaa virheille. Tällaisia voivat olla epäselvän nimeämiskäytänöön mukaisesti määritetyt attribuutit, väärät tietotyypit, ja epäselvät pääavain - vierasavain yhteydet. Tiedon yksikäsitteisyyteen (kts. luku 2) eli tiedon toistumiseen liittyvät ongelmat voivat tulla esiin vasta pitkänkin käytön jälkeen ja pahimmillaan aiheuttaa sen, ettei tietokannan tietoeheyteen enää voida luottaa.
Alla nähdään pieni esimerkkitietokanta jossa ilmenee joitain tällaisia puutteita, mutta jotka kuitenkin olisi varsin helposti tunnistettavissa ja korjattavissa.
Sanottakoon, että alla nähdyn kaltaisia ongelmia ei ikinä pitäisi esiintyä tietokannassa, joka on huolella suunniteltu (esimerkiksi käsitemallin avulla). Jos vielä käytetään normalisointimenetelmiä (luku 16), voidaan tällaiset ongelmat lähes tyystin välttää. On kuitenkin hyvä tarkastella ainakin yksi selkeä esimerkkitapaus ja siten luoda valmiuksia mahdollisten perusongelmien havaitsemiseen muissa vastaavanlaisissa relaatiotietokannoissa.
 

9.4.1 ESIMERKKITIETOKANTA KALANKASVATTAMOT
Ohessa on annettu esimerkkitietokannan taulujen rakenne ja havainnollistettu taulujen välisiä avainyhteyksiä attribuutit yhdistävillä viivoilla. Tietokannassa on joitain selkeitä puutteita, jotka vaikeuttavat sen käyttöä tai luovat tavallista paremmat edellytykset virheiden synnylle.
Tietokanta mallintaa seuraavia tietoja:
• Kalankasvattamot/tilat, joissa kussakin on kasvatusaltaita ja altaissa edelleen kaloja jotka ovat jotakin lajia.
• Tilojen omistajat/kasvattajat
• Altaista otetaan säännöllisesti mittauksia (vedestä esim.) ja mittauksia tekee useampi eri yritys, joilla taas on mittaajia suorittamassa itse mittaukset.
• Mittaustulokset on tallennettu tietokantaan ja ne ovat saatavissa allaskohtaisesti.
 
Kuva 2: Tietokannan rakenteessa puutteita

 

9.4.2 RAKENTEEN ONGELMIA
	• Attribuuttien nimeäminen
	Taulujen väliset avainyhteydet on helppo hahmottaa kuvasta, mutta jos niitä ei olisi piirretty näkyviin, vaatisi rakenteen ymmärtäminen huolellista tarkastelua. Suositeltava käytäntö olisi pyrkiä nimeämään vierasavain aina yhtäläisesti siihen liittyvän pääavaimen kanssa. Yllä esimerkiksi Allas, Mittaus ja Mittaaja tauluissa pääavainten ja vierasavainten välillä ei ole nimien suhteen mitään selvää yhteyttä.
	
	Epäselvä nimeäminen ei ole varsinainen virhe, mutta laajemmassa tietokannassa johtaisi käytettävyysongelmiin kun käyttäjän tulisi yrittää muistaa miten mikäkin asia kussakin tauluassa nimettiin.
	• Pääavainten valinta
	Tauluissa Mittaaja, Tila ja Kasvattaja käytetyt pääavaimet eivät ole parhaita mahdollisia. Nimi pääavaimena voi toimia pienissä tietokannoissa, mutta on aina muistettava ettei saisi olla mahdollisuutta pääavaimen saada kahta samaa arvoa eri tietueille. Ei edes sen jälkeen jos/kun tietokanta kasvaa tulevaisuudessa! Voiko vastaan tulla kaksi saman nimistä mittaajaa, kun nimi annetaan muodossa "etunimi väli sukunimi"? Varmastikin voi.
	Tietämättä tarkemmin miten tilan nimi määritetään, voi se olla kelvollinen pääavain. Tällöinkin on oltava yhteisymmärrys kaikilla osapuolilla, miten tuo nimi kirjoitetaan. "Mäntyharjun kala" on eri asia kuin "Mäntyharjun Kala," kun uusia tietoja lisätään tai päivitetään.
	Oma lukunsa on Allas taulun yhdistetty pääavain. On ajateltu että se tarvitaan, koska nyt allas on yksilöity numeron ja tilan perusteella siten, että kaikilla tiloilla on altaita numerosta "1" alkaen: 1,2,3,4... jne. Koska heti toisen tilan lisäämisen jälkeen tulisi sama allasnumero uusiksi Allas taulun pääavaimeksi (1, 2, jne), on Tila taulusta tuleva vierasavain otettu mukaan pääavaimeen. Allas pääavain on siis muotoa: "1, Mattilan tila", "2, Mattilan tila" jne.
	Jotta nykyinen ratkaisu toimisi, tulisi Mittaus taulussa olla vierasavaimena koko allas taulun pääavain. Mistä muuten tiedetään, minkä tilan altaaseen "nro 3" mittaus X liittyy? Jos taas Numero on jo nyt yksilöivä, globaali ID arvo, niin yhdistetty avain on yksinkertaisesti turha, eikä sitä tarvita.
	Jos kukin allas yksilöitäisiin globaalilla ID:llä, ei sitä tarvitsisi sitoa kaksoispääavaimen kautta Tilaan. Tämä ratkaisu voisi olla parempi, sillä silloin allas on aina yksilö ilman riippuvuutta tilasta. Tila on vain sen ominaisuus. Nyt jos tilan nimi muuttuu, tai tila yhdistyy toisen kanssa, nykyinen pääavain tuottaisi ongelmia Mittaustauluun saakka johon se olisi tuotava, kuten yllä esitettiin.
	• Tiedon toistuminen
	Taulujen Tila ja Allas välillä toistetaan tietoa. Tilalla on Laji. Kuitenkin myös Allas taulussa on annettu allaskohtaisesti Laji. Vaikka olisikin niin, että kaikilla tilan altailla on aina sama kalalaji (varsin epätodennäköistä), ei sellaiseen voisi tietokantaa sitoa olettamuksella että näin on aina tulevaisuudessakin. Toisaalta, jos Laji muutetaan Lajit nimiseksi listaksi tilan kalalajeista, toistaa se vain saman tiedon joka on saatavissa tilan altaista. Tämä on turhaa ja haitallista: Sama tieto toistuu eri tauluissa ja sen ylläpitämiseksi oikeana on aina muutokset kohdistettava kahteen eri paikkaan.
	
	Voidaan myös väittää, että Tila taulun attribuutti Altaita (lukumäärä) on samoin turha, sillä altaiden kulloinenkin lukumäärä on nähtävissä tilaan liittyvistä altaista yksinkertaisen SQL-kyselyn tai näkymän kautta. Kun tilan allasmäärä muuttuu, pitäisi riittää että Allas-tauluun lisätään/poistetaan allas. Nyt päivityksiä tulee tehdä kahteen eri paikkaan. Tästä voisi olla edullista hankkiutua eroon. Jos allasmäärä on tärkeä, voidaan luoda ja tallentaa kysely tai näkymä (kts. luku 15) joka antaa aina allasmäärän per haluttu tila.
	Tilalle on myös erikseen tallennettu Omistaja, ja toisaalta taulussa Kasvattaja on annettu Tilan nimi. Onko omistaja sama asia kuin kasvattaja, vai voiko olla useita kasvattajia, joista joku on omistaja? Onko erillinen omistaja tieto tarpeen, vai riittääkö tilaan liittyvien kasvattajien tiedot? Näyttää että jälleen samaa tietoa toistuu eri nimillä eri paikoissa. On myös epäselvää mitä oikeastaan tarkoitetaan Tila-Kasvattaja yhteydellä.
	• Tietotyypit
	On hyvä muistaa tietotyyppiä valittaessa, että lukuarvo/numero todellakin on aina lukaurvo. Jos puhelinnumero merkitään lukaurvoksi, ei viiva "-" ole kelvollinen merkki syötteelle ja esim. puhelinnumero "040-1231231" hylätään. Yhtälailla arvosta "+358401231231" todennäköisesti katoaa plus-merkki edestä, sillä lukaurvossa ei tarvitse erikseen kertoa että arvo on positiivinen. TKHJ:han näkee syötteen numerona. Samoin "0405432123" kadottaa ensimmäisen nollansa: se on lukuarvossa merkityksetön!
	Puhelinnumeroihin olisi siis syytä vaihtaa tietotyypiksi teksti, tai luoda uusi käyttäjän tietotyyppi nimeltään Puhnro tms. kuten tässä luvussa on jo kerrottu.
 

9.4.3 KALANKASVATTAMOT, KORJAUSEHDOTUS
Alla on esitetty yksi lukuisista eri tavoista korjata esimerkkitietokannan puutteita. Tämäkään ei vielä ole täydellinen toteutus, sillä voisi olla tarpeen kertoa Kasvatta taulussa, onko hän myös tilan omistaja. Toisaalta, jos kasvattajaan voisi liittyä useita tiloja, olisi luotava Tilan ja Kasvattajan välille yhteystaulu (yhteysyksilötyyppi käsitemallissa, M:N suhteen purku).

 
Kuva 3: Rakennetta korjattu monilta osin



9.5 Avainyhteys: Linkki vai jotain muuta?
Luvun lopuksi tarkastelemme vielä erästä kysymystä joka usein nousee esiin relaatiomallin pää-vierasavain yhteyksiä mietittäessä: Minkälaatuinen yhteys pääavaimen ja vierasavaimen välillä oikeastaan on?
 

9.5.1 LOOGINEN YHTEYS EI OLE OSOITIN TAI LINKKI
Termiä linkki käytetään usein ja se eittämättä helpottaa yhteyksien hahmottamista, erityisesti relaatiomalliin tutustuttaessa. Linkki voi myös olla harhaanjohtava termi. Linkki voi antaa ymmärtää, että pääavain-vierasavain arvopari olisi sidottu tai linkitetty yhteen niin, että jos pääavain vaihtuu, niin siihen linkitetty vierasavain päivityy myös automaattisesti, aivan kuin niiden välillä olisi ketju tai vastaava joka vetää toisen osoittamaan oikeaan kohtaan. Samoin ymmärretään joidenkin muiden tietomallien osoittimet: Vierasavain "osoittaisi" oikeaan pääavainarvoon, ja jos pääavaimen arvo muuttuu, päivittyy vierasavaimen osoitinkin vastaavasti.
Näin ei ole relaatiomallissa.
Tarkastellaan ennestään tuttuja tauluja Työntekijä ja Työskentelee. Yksi vallitseva pääavain-vierasavainyhteys on merkitty näkyviin.
 
Tyoskentelee
	
	TyontekijaID	ProjektiID	Rooli	Aloittaa	Vapautuu
	1	2	Projektipäällikkö	3/2004	12/2004
	1	5	Projektipäällikkö	9/2004	11/2005
	3	1	Sovelluskehittäjä	2/2004	6/2005
	4	4	Testauspäällikkö	1/2005	11/2005
	4	2	Sovelluskehittäjä	3/2004	1/2005
	5	1	Projektipäällikkö	10/2003	2010
	4	5	Sovelluskehittäjä	2/2005	10/2005

Tyontekija
 
	
	TyontekijaID	Nimi	ToimipaikkaID	PuhNumero	Kotiosoite
	1	Niemi Jukka	Lpr	358 040-512512	Lehmustie 1 A2...
	2	Tuomela Terhi	Lpr	358 050-123456	Jupiterinkatu 102
	3	Sillanpää Salla	Hki-1	358 045-654321	Mikonkatu 17 C4
	4	LeBlanc Custou	Hki-1	358 046-123123	Hirvitie 10, 43850
	5	Somerjoki Reijo	Hki-2	358 040-123321	...23400, Helsinki
	6	Smith Adam	Lontoo	123 560123123	Bridge Road 53...
	7	Hanes Mark Jr.	Lontoo	123 900190121	Pine Street 1 B 5
 
Yhteys TyöntekijaID arvon 4 ja Tyoskentelee taulun TyontekijaID arvojen 4 välillä on puhtaasti looginen. Sitä ei ole sidottu mitenkään relaatiomallin tasolla, ellei aseteta voimaan erityisiä sääntöjä tämän voimassa pitämiseksi. Yhteys on olemassa vain koska nämä arvot täsmäävät. Jos Tyoskentelee taulun ensimmäinen TyontekijaID arvo 4 muutetaan vaikkapa arvoksi 2, katoaa tämä aiemmin ollut looginen yhteys, ja nyt on muodostunut uusi looginen yhteys Tyontekijan jonka ID on 2 ja Tyoskentelee taulun välillä.
On siis selvää, ettei vierasvain Tyoskentelee(TyontekijaID) osoita tai linkity mihinkään Tyontekija taulussa. Siellä vain sattuu olemaan samoja arvoja samanlaisella attribuutilla. Itseasiassa, kun puhumme vierasavaimesta pääavainattribuutin "tuomisena" vierasavaintauluun, todellisuudessa tarkoitamme vain samanlaisen attribuutin luomista vierasavaintauluun. Attribuuttien välillä ei ole mitään yhteyttä edes rakennetasolla -- relaatiomallin kannalta ne ovat vain samanlaisen tietotyypin, samanlaisen nimen jne. omaavia attribuutteja erinimisissä tauluissa. Se, että kerromme SQL kielellä tämän oleva vierasavain tuohon pääavaimeen, tarkoittaa vain tiettyjen eheyssääntöjen voimaansaattamista attribuutille joka muuten on täysin normaali. Määrittämällä vastaavat yksinkertaiset eheyssäännöt käsin, voisimme luoda vierasavaimia attribuuteista ilman SQL-kielen REFERENCES määritettä.
 

9.6 Keskeisiä termejä suomeksi ja englanniksi
Avainehdokas, toisioavain; candidate key
	Avainehdokas on attribuutti, josta voisi tulla taulun pääavain. Se voi siis yksilöidä taulun tietueet. Avainehdokas voi koostua attribuuttijoukosta.
Avainyhteys
	Looginen yhteys kahden avainehdokkaan välillä. Yhteys muodostuu täsmäävistä arvopareista. Eli  jos vierasavaimen tai pääavaimen arvo muuttuu, eikä toista niistä muuteta vastaavasti, katoaa aiemmin vallinnut yhteys. Tavallisesti avainyhteys on pääavaimen ja vierasavaimen välillä, ja tämä on suositeltava tapa muodostaa avainyhteyksiä.
	
10. Lisää suunnittelusta
38. Suunnitteluprosessista
39. Käsiteanalyysin vaiheet
40. Levyarkiston suunnittelu
41. Levyarkisto, ensimmäinen käsitekaavio hahmoteltuna
42. Levyarkisto, korjattu käsitekaavio
43. Käsitekaavio ja yhteystyyppisilmukat
44. Käsitemallin kuvantamismenetelmistä


Käsiteanalyysin vaiheet
Luvussa 3 esiteltiin seuraava käsiteanalyysin karkea vaihejako:
 

Tässä luvussa tarkennetaan tätä kuvausta. Lisäksi luodaan käsitemalli laajennetulle "äänitearkisto ja lainaukset" -tietokannalle ja samalla pohditaan suunnitteluprosessin etenemistä ja nähdään, miten valmiinkin oloisessa tietomallissa voi olla vielä runsaasti puutteita ja pohdittavia piirteitä.
 

10.1 Suunnitteluprosessista
Luotaessa laajoja tietokantajärjestelmiä edeltää varsinaista käsiteanalyysia joukko muita, hyvin korkean tason suunnitteluvaiheita. Tällöin voidaan muodostaa erilaisia toimintoanalyysejä ennen käsiteanalyysiä tai sen rinnalla. Toimintoanalyyseillä hahmotetaan kohdealueella olevia toimintoja esimerkiksi erilaisten tietovuokaavioiden avulla. Pyritään selvittämään, mitä toimintoja kohdealueella olevat ilmiöt suorittavat tai millaisia toimintoja voi olla tarpeen suorittaa. Toimintoja voivat olla levyarkistossa äänitteen lainaaminen ja lainaan ottaminen. Tällaisten toimintojen löytäminen voi olla helpompaa, jos se tehdään käsiteanalyysin rinnalla, jolloin yksilötyyppien etsiminen, ja toisaalta niiden suorittamien tai niihin kohdistuvien toimintojen etsiminen, tukevat toisiaan.
Laajoissa toteutuksissa voidaan käsiteanalyysin rinnalla tai sen jälkeen suorittaa vielä erityinen tietotarveanalyysi. Kun tiedetään kohdealueella olevat yksilötyypit ja toimenpiteet jotka liittyvät yksilöihin, voi olla tarpeen vielä etsiä mitä tietoja kyseisen yksilötyypin on tunnettava tai saatava jotta se voi täyttää oman roolinsa. Esimerkiksi levyarkistossa voidaan havaita, että yksilötyypillä "Lainaus" on tietotarve joka vaatii, että lainauksen tyyppi on tunnettava silloin kun lainaus kohdistuu kaveriin, mutta jos lainaus on kirjastosta tapahtunut, ei siihen liity mitään muita tietotarpeita.
Pienempiä tietokantoja, kuten juuri levyarkisto tms., suunniteltaessa toiminnot hahmottuvat käsiteanalyysin myötä. Yleensä myös yksilötyyppien tietotarve selviää ominaisuustyyppien yksilötyyppien ja yhteystyyppien etsimisen myötä.
Tässä yhteydessä ei käsiteanalyysistä erillisiin suunnitteluvaiheisiin kiinnitetä tämän laajemmin huomiota.
 

10.2 Käsiteanalyysin vaiheet
Jotta käsitekaavio syntyisi mahdollisimman vaivattomasti ja mahdollisimman oikeanlaiseksi jo heti kättelyssä, on aiheellista noudattaa sen laatimisessa systemaattista lähestymistapaa. Seuraavanlainen vaihejako on havaittu toimivaksi. On syytä huomata, että monesti tämän tulos voi olla vielä relaatiomallista riippumaton.
45. Yksilötyyppien määritys
	Yksilötyypit listataan. Tämän jälkeen seulotaan pois synonyymit ja merkitään homonyymit näkyviin. Yksilötyypeille laaditaan halutuntasoinen kuvaus. (kts. alempana)
46. Yhteystyyppien määritys
	Yhteystyypit etsitään yksilötyyppien perusteella. Nyt voidaan hahmottaa käsitemallin perusrakenne. Yhteystyyppien aste määritetään ja merkitään näkyviin. Mikäli tarpeen, merkitään yksilötyypeille alityyppejä, jos yhteystyyppi kohdistuu vain osaan alityyppiä tai sen yhteen ilmentymään. (esim. Lainaus voi olla suhteessa Kaveriin kahdella tavalla, OtettuLainaan tai AnnettuLainaan, kun taas kirjastoon voi olla vain suhde OtettuLainaan.) Jos löydetään M:N suhteita, puretaan ne ja suoritetaan tarpeelliset muutokset.
47. Avainten ja avaineheyksien määrittäminen
	Etsitään jokaiselle yhteystyypille pääavain ja avainehdokkaat. Päivitetään yksilötyyppikuvaukset. Mikäli tarpeen, muokataan käsitemallia. Tämän jälkeen määritetään avaimiin kohdistuvat eheyssäännöt. Yleensä relaatiomallin TKHJ:t pitävät avaineheyksistä huolen automaattisesti, mutta jos käsitemalli on tuoteriippumaton, on hyvä kirjata kullekin avaimelle eheyssäännöt. Avainehdokkaille eheyssääntöjen miettiminen voi olla tarpeen silloinkin kun toteutuksen kohdealusta tunnetaan.
48. Ominaisuustyyppien määritys
	Etsitään yksilötyypeille ei-avain ominaisuustyypit ja päivitetään yksilötyyppikuvaukset. Jos tarpeen, muutetaan käsitemallia. Tarkistetaan eritoten että mikään löydetty ominaisuustyyppi ei olekaan itseasiassa uusi yksilötyyppi, ja toisaalta, että kaikki löydetyt yksilötyypit ovat edelleen aitoja yksilötyyppejä, eivätkä sittenkin toisen yksilötyypin ominaisuuksia.
49. Muiden eheyssääntöjen määrittäminen
	Mietitään ja merkitään muistiin eheyssäännöt jotka kohdistuvat ominaisuustyyppeihin, yksilötyyppeihin ja yhteystyyppeihin. Erityisesti yhteystyyppien ehdollisuus voi olla mielenkiinnon kohteena: esim. Tenttiin ei voida ilmoittautua(yhteystyyppi) ellei Kurssi_Ilmoittautuminen (yhteystyyppi) ole olemassa. Yhteystyypin olemassaolo estää/mahdollistaa toisen olemassaolon. Sama yksilötyypeille ja ominaisuustyypeille. Esimerkkejä eheyssäännöistä on annettu luvussa 9.
50. Käsitemallin tarkistus
	Viimeinen vaihe on käsitemallin huolellinen tarkistus. Tähän vaiheeseen voi myös sisältyä normalisointitarkistus, jota käsitellään luvussa 16. Sen avulla voidaan varmistua rakenteen relaatiomalli-teknisestä toimivuudesta, mutta edes normalisointi ei voi estää ongelmia joita voi syntyä jos käsitemallista jätetään pois sinne todellisuudessa kuuluneita yksilötyyppejä tai virheellisesti määritettyjä eheystyyppejä. On myös syytä käydä vielä läpi jokainen yksilötyyppi ja ominaisuustyyppi ja varmistua niiden tarpeellisuudesta sekä siitä, että mitään niiden tarvitsemaa ei myöskään puutu.

	 
10.2.1 KÄSITEMALLISTA RELAATIOTIETOKANNAKSI
Kun käsitemallin oikeellisuudesta ollaan varmoja, voidaan alkaa siirtämään sitä relaatiomalliksi. Tällöin yksilötyypit muuttuvat tauluiksi, ominaisuustyypit attribuuteiksi ja yhteystyypit avainattribuuttien kautta avainyhteyksiksi. Yksilötyyppikuvauksista nähdään attribuutin tuleva tietotyyppi tai se johdetaan vapaamuotoisesta kuvauksesta ("merkkijono" -> VARCHAR). Tässä yhteydessä voidaan päätyä luomaan omia tietotyyppejä relaatiotietokantaan. Eheyssäännöt implementoidaan relaatiotietokantaan TKHJ:n mahdollistamissa puitteissa. Suurinta osaa avainten eheyssäännöistä ei todennäköisesti tarvitse luoda ollenkaan, sillä TKHJ pitää niistä automaattisesti huolen. Tähän ei kuitenkaan pidä sokeasti luottaa, vaan käytetyn alustan ominaisuudet on hyvä tuntea etukäteen.
 

10.3 Levyarkiston suunnittelu
Esimerkkinä on alempana esitetty käsitekaavioehdotus tietokannalle, jonka kuvaus annetaan tässä. Samalla on esitetty miten kyseiseen malliin voitaisiin päätyä, ja lopulta arvioitu, onko kyseinen malli vielä lopullinen vai vaatisiko se edelleen muokkausta ennen relaatiomalliin siirtoa.
 

10.3.1 KOHDEALUEEN/ONGELMAN KUVAUS
Tarkoituksena on luoda äänitearkisto. Alustavan analyysin seurauksena päädytään seuraavaan yleiskuvaukseen: Tietokannassa tulisi esiintyä tietoja arkistoiduista äänitteistä (CD-levy, vinyylilevy, kasetti). Äänitteistä tulisi olla tiedot kappaleista/raidoista. Jokaisesta kappaleesta tulisi selvitä sen esittäjä ja tekijä/tekijät (säveltäjä, sanoittaja jne.). Äänitteen kulloinenkin sijainti on oltava tiedossa (hyllyssä, autossa, kesämökillä, jne.) Toisaalta, koska äänitteitä annetaan ja saadaan lainaan kavereilta, pitäisi tieto lainaustilanteesta olla tietokannassa mukana. Lainauksia voi myös olla kirjastosta, ja tällöin olisi hyvä tietää mikä on lainan eräpäivä.
10.3.2 KÄSITEMALLIN MUODOSTAMINEN
Mallin luominen voisi alkaa kuten alla.
	Yksilötyypit:
	Löydetään aluksi seuraavat yksilötyypit: Äänite, Arkistointipaikka/Sijainti, Kappale/raita (päädytään nimeämään kappaleeksi), Artisti, Kaveri, Lainaus.
	Yhteystyypit:
	Mietitään minkä yksilötyyppien välillä on yhteys, ja mikä on sen aste: Äänite 1 - N Kappale, Äänite 1 - 1 Sijainti,  Kappale N - M Artisti,  Äänite N - M Lainaus , jne.
	Havaitaan, että on muodostettava uusia yksilötyyppejä, sillä löytyi M:N yhteyksiä.
	 
	Lisää yksilötyyppejä:
	Palataan alkuun: Lisätään yhteysyksilötyyppejä: Kappale 1 - N Suhde/Rooli N - 1 Artisti; Äänite 1 - N Lainassa N - 1 Kaveri.
	Nyt edetään taas vaiheeseen kaksi, ja määritetään yhteystyypit uusiksi.
	Toistetaan, kunnes muutoksia ei enää tule. Vasta sitten voidaan siityä avaimiin ja ominaisuustyyppeihin. Iteroidaan nämä vaiheet samalla tavalla, eli jos muutoksia syntyy, käydään edeltävät vaiheet uudelleen läpi kunnes muutoksia ei enää tule.


Lopulta päädytään tiettyihin yksilötyyppeihin ja yhteystyyppeihin, sekä tiedetään avaimet ja ominaisuustyypit. Tällöin olisi hyvä olla käsitekaavio piirrettynä. Yksilötyyppikuvaukset liitetään käsitemallin oheen. Niiden laajuus on kiinni tietokannan koosta ja haastavuudesta. Yksi esimerkki alla:
 
Äänite
 
Tyypin mukaiset yksilöt ovat äänitearkiston äänitteitä. Äänite voi olla tyypiltään jokin seuraavista: CD-levy, vinyylilevy, kasetti. Äänitteen Esittäjä tieto on äänitteen koteloon, kanteen tms. painetun merkinnän mukainen. Yksittäisen kappaleen todellinen esittäjä ei ole tämän yksilötyypin vastuulla. (kts. Kappale)


Ominaisuustyyppi	Tietotyyppi	Määritteet
ÄäniteID	kokonaisluku	Pääavain, ei oletusarvoa
Nimi	teksti, 1 - 50 merkkiä	Pakollinen, ei oletusarvoa
Tyyppi	Äänitetyyppi	Pakollinen, ei oletusarvoa
Esittäjä	teksti, 1 - 50 merkkiä	ei pakollinen, ei oletusarvoa
jne..	 	 
 
Yksilötyyppikohtaiset eheyssäännöt
 
Yksilötyypin mukaisia yksilöitä voidaan lisätä vapaasti.

Yksilöä ei voida poistaa niin kauan kuin yksilön pääavaianrvo esiintyy vierasavainarvona Kappale yksilöllä tai Lainassa yksilöllä tai Sijainti yksilöllä. Tällaiset yksilöt on poistettava ensin jos sellaisia on.


Yllä Yksilötyyppikohtaiset eheyssäännöt voivat osittain kuulua avaimiin määritettyihin eheyssääntöihin. Näin olisi sen suhteen, että voidaanko äänite poistaa tietokannasta ja missä tilanteessa: Kysehän on avainyhteyksistä. Käsitemallin tekijä päättäköön, ilmoittaako tämän avaineheyssääntönä vai vapaamuotoisesti yksilötyyppisääntönä. Jos on selvää, että mallista muodostuu relaatiotietokanta, eikä sitä haluta säilyttää tietomallineutraalina, voi suunnittelija myös jättää merkitsemättä sellaiset eheyssäännöt, esim avaimiin liittyen, jotka relaatiomalli asettaa väistämättä. Esimerkiksi pitäisi olla automaattisesti selvää, että Äänite yksilö ei voida poistaa, jos sen pääavainarvoon on vierasavainviittaus yhdestäkään Kappale yksilöstä. Toisaalta, kaikki relaatiomallia noudattavat järjestelmät eivät pakota tietokantaa relaatiomallin mukaiseen tilaan. Suunnittelija siis päättäköön tarpeen mukaan eri tyyppisten eheyssääntöjen tarpeellisuudesta.
Koska yksilötyypin yhden ominaisuustyypin tietotyyppi on itse luotu, on syytä kirjata tämän tietotyypin kuvaus ylös. Sallitut arvot jne. Esim: Äänitetyyppi(sallitut arvot: "CD", "Vinyyli", "Kasetti"; muoto merkkijono)
Toisaalta, joskus on tapana koota lisäys- ja poistosäännöt yhteen listaan, eikä noteerata niitä yksilötyyppikohtaisesti.
Valittakoon mikä käytäntö tahansa, olennaista on miettiä ja kirjata käsitemallin eri osiin kohdistuvat eheyssäännöt ja tehdä se samoin koko suunnitteluprosessin ajan.
 

10.4 Levyarkisto, ensimmäinen käsitekaavio hahmoteltuna
Edellä olleen perusteella on laadittu ensimmäinen versio käsitemallista. Se on esitetty alla. Käsitekaaviota tarkastellessa havaitaan joitain piirteitä, joiden perusteella päätetään, ettei se vielä voi olla lopullinen. Mallin tiettyjä osia on hahmotettu kaavion alla relaatiomallin näkökulmasta.
 

10.4.1 KÄSITEMALLI


 
Kappale - Artisti suhde muodostuu yhteysyksilötyypin kautta, joka purkaa M:N yhteyden (Artistiin voi liittyä useita kappaleita ja kappaleeseen voit liittyä useita artisteja). Artistilla on kolme alityyppiä. Ne on nmerkitty, koska Rooli yksilötyypissä tämä tieto on läsnä kolmoisavaimen muodossa. Näin on mahdollinen tilanne, jossa samalla artistilla on useita rooleja samassa kappaleessa -- tällöin suhteen tyyppi eli kolmas avainkomponentti erottaa suhteet toisistaan ja pääavainarvo pysyy yksilöllisenä. Samoin voi useampi artisti olla samassa roolissa samaan kappaleeseen nähden, esim. esittäjiä voi kappaleella olla useita. Tätä rakennetta on havainnollistettu alla taulujen muodossa.
Äänite voi olla lainassa. Lainassaolo on kahta eri tyyppiä: kirjasto tai kaveri. Täten Kaveriin liittyvä Lainassa yksilö yhdistyy vain toiseen alityypeistä, ja siksi alityypit on tuotu käsitemallissa esiin: Korostetaan, että kaverilta tuleva lainausyhteys ei kohdistu eikä voi kohdistua kaikkiin lainauksiin, vaan ainaostaan niihin joiden tyyppi on "kaveripiiri." Alityypin käyttö on tässä tapauksessa välttämätöntä.
 

10.4.2 RAKENTEEN OSIA KUVATTUNA
Oheisessa kuvassa on esitetty yllä mainittuja piirteitä relaatiomallin näkökulmasta. Varsinaisia tarkkoja tietotyyppejä ei ole käytetty vielä tässä vaiheessa.
 



10.4.3 ONKO MALLI VALMIS?
Onko käsitemalli nyt valmis? Tätä tulisi arvioida käymällä uudelleen läpi ongelmakuvaus ja pohtimalla kriittisesti vastaako malli nyt sille asetettua tarkoitusta. Esitetyn rakenteen kriittinen tarkastelu paljastaa, että se ei vielä voi olla valmis malli toteutettavalle relaatiotietokannalle. Tähän on ainakin seuraavia syitä.
Voidaan todeta, että vaikka Sijainti onkin tärkeä tieto, ja joistain sijaintipaikoista voi olla tarpeen tallentaa erillisiä tietoja (osoite yms.), niin onko tämä todella tarpeen? Riittääkö, että sijainti on Äänitteen ominaisuus, eikä erillinen yksilötyyppi? Sijainnin on oltava yksilötyyppi vain, jos sijainneista todellakin on tarpeen esittää niihin liittyviä ominaisuuksia, ts. attribuutteja eli ominaisuustyyppejä. Onko hyllypaikalla, auton hansikaslokerolla tai kesämökillä ominaisuuksia joita tulee esittää tietokannassa? Todennäköisesti ei ole. Tarpeen on ainaostaan kertoa äänitteen sijainti. Sijainti on siis vain äänitteen ominaisuus, mistä seuraa, että poistamme tämän turhan yksilötyypin ja luomme äänitteelle ominaisuustyypin Sijainti tai vastaava. Se kertoo missä kukin äänite milloinkin on. Jos tarpeen, voimme luoda sijainnille edelleen oman (käyttäjän luoman) tietotyypin, jonka avulla on helppo kertoa sijainti.
Artisti - Rooli - Kappale yhteys näyttää myös epäoptimaaliselta: Se on rakennettu oikein, mutta siihen ei todellisuudessa sisälly alityyppejä. Tämä ei ole iso muutos, sillä toteutettava rakenne on oikea joka tapauksessa. On kuitenkin syytä huomata, että Esittäjä, Säveltäjä ja Sanoittaja ovat itseasiassa Rooli yksilöttypin ominaisuustyypin Rooli sallittuja arvoja, ts. valmiin tietokannan attribuutin Rooli saaman tietotyypin arvoja. Ne olisivat alityyppejä lopullisessa kaaviossa vain, jos artistin omaksuessa jonkin näistä rooleista sen suhteen aste kappaleeseen muuttuisi (esim jos olisi sallittua olla vain yksi sanoittaja tai säveltäjä per kappale, mutta useampi esittäjä -> olisi 1:1 ja 1:N asteisia suhteita -> sanoittaja ja säveltäjä olisivat oma alityyppinsä, jolla olisi 1:1 suhde kappaleeseen, ja esittäjä vastaavasti omansa, johon taas olisi 1:N suhde kappaleesta). Tässä ei myöskään ole samanlaista tilannetta kuin Kaveri - Lainaus - Lainassa rakenteessa, joten alityypit ovat turhia. Toisaalta, koska kyseessä on tietokannan kannalta merkittävä rakenteellinen piirre, voitaisiin ne jättää tästä huolimatta, kunhan ollaan tietoisia mistä ne todellisuudessa kertovat.
Voidaan myös kysyä, olisiko parempi ratkaisu luoda erilliset yksilötyypit LainassaKirjastosta ja LainausKaveri. LainausKaveri edelleen olisi suhteessa Kaveri yksilötyyppiin. Nythän Lainaus on olemassa koska kaverille lainaus voi olla kahta tyyppiä: Otettu lainaan, tai annettu lainaan. Edellinen ratkaisu säästäisi tältä ylimääräiseltä yksilötyypiltä. Lisäksi nytkin Lainaus taulun kaksoispääavain on turha: Yksilötyyppi toimi kaavion aiemmassa versiossa yhteysyksilötyyppinä, ja siinä tämä oli tarpeen. Nyt se ei enää ole, koska LainausID on yksilöllinen aina jokaiselle lainalle. Tämä olisi edelleen tarpeen korjata, jos rakenne päätetään säilyttää ennallaan eikä yllä ehdotettua muutosta tehdä. Jos muutos tehdään, eli luodaan LainausKirjasto ja LainausKaveri yksilötyypit, yksinkertaistuu rakenne jonkin verran. Yksinkertaisuus on toki tavoiteltavaa, mutta toisaalta, jos mallia on tarpeen joskus laajentaa, eikä haluta sitoa sitä turhan tiukkaan muottiin, on nyt toteutettu rakenne suotavampi, sillä sen avulla on helpompi jatkossakin välttää ns. kierto ilmiötä (luku 10.6) silloinkin kun rakenteeseen tuodaan uusia yksilötyyppejä joilla voi olla yhteys molempiin lainaustapoihin.
 
On helppoa nähdä, että yksinkertaiseenkin tietokantaa voi sisältyä paljon pohdittavia piirteitä. Nytkin on vielä auki, miten lainausten tietotyypit oikein määritetään, ja tulisiko Lainaus taulussa käyttää tietotyyppiä "LainausKaveri" ja Lainassa taulussa taasen erillistä tietotyyppiä "Lainassa" tms.
Nähdään myös, että käsitemallin hahmottuessa on syytä muistaa korjausten yhteydessä pitää huoli ettei mitään viattoman näköistä, mutta turhaa, jää. Tästä Lainassa kaksoisavain on oiva esimerkki. Siihen ei äkkiseltään kiinnitä huomiota, ja koska kyseessä on eräänlainen yhteysyksilö, voidaan se jopa ajatella itsestäänselvänä ilman syvällisempää tarkastelua.


10.5 Levyarkisto, korjattu käsitekaavio
Mallin tarkistusten myötä päädyttiin tekemään muutoksia. Syntyi ehdotelma valmiiksi käsitemalliksi. Voitaisiinko nyt alkaa siirtämään mallia relaatiotietokannaksi?
Alla on annettu uusi versio käsitemallin joistain osista. Yksilötyyppien kuvaus ei sisällä tietoja siitä, onko ominaisuustyypin arvo pakollinen, ja mitä ovat oletusarvot. Yksinkertaisuuden vuoksi yksilötyyppikuvauksia ei ole annettu sanallisesti lainkaan. Eheyssäänntöjä on kirjattu karkealla tasolla. Vähintään tämän asteiset eheyssäännöt tulisi kuitenkin olla tiedossa.
 

10.5.1 KORJATTU KÄSITEMALLI
 



10.5.2 MALLIN LISÄKUVAUS

 
Käsitemallissa oli poistettu Sijainti, ja siirretty se Aanitteen ominaisuudeksi. Lainaus on nimetty nyt KaveriLainaus, ja sen kaksoispääavain on poistettu turhana. Samalla KaveriLainaus - Lainaus yhteys päivitettiin 1:1 asteiseksi. Artisti - Rooli - Kappale alityypit poistettiin, joskin taulujen rakenteeseen tämä ei vaikuttanut.
Mainittakoon, että oheiset eheyssäännöt pitäisivät toteutua automaattisesti TKHJ:n toimesta. Ne voitaisiin täten myös jättää pois, jos mallin kohdejärjestelmäriippumattomuutta ei ole tarpeen säilyttää. Silloinkin voisi olla tarpeen mainita esim. seuraavanlainen eheyssääntö: "Jos lainaus on tyyppiä 'kirjasto', ei kys. äänitetteeseen voi liittyä kaveri tyyppistä lainaa." tai "Jos lainaus on tyypiltään kirjasto, ei siihen liittyvää äänite yksilöön voida liittää kaveri tyyppistä lainausta jonka eräpäivä on myöhempi kuin kys. kirjasto lainauksen eräpäivä" jne.
Esitettäköön vielä ylempänä mainittu yksinkertaisempi versio korjatusta mallista. Tähän tosin eivät enää edellisen kuvan kaikki taulut sopisi sellaisenaan johtuen lainauksiin liittyvistä muutoksista.
 

 

10.6 Käsitekaavio ja yhteystyyppisilmukat
Tarkastelemme vielä lopuksi erästä käsitekaavion piirrettä, joka olisi hyvä huomioida yhteystyyppejä määritettäessä ja tarkistaa valmista käsitekaaviota arvioitaessa.
Yhteystyyppien, tai yhteyksien, silmukalla tai kierrolla tarkoitetaan alla kuvatun kaltaista tilannetta, jossa lähtemällä yksilötyypistä seuraamaan siihen liittyvää yhteystyyppiä, on mahdollista päätyä toisen yhteystyypin kautta (syntyy silmukka) takaisin lähtöpisteeseen. Tällainen rakenne ei ole toivottava mahdollisimman hyvin toimivan relaatiotietokannan toteutumiseksi.
 

 
Kuvassa nähdään, että yllä yksilötyypit 1, 2 ja 4 muodostavat kierron. Lähtemällä mistä tahansa näistä yksilötyypeistä seuraamaan yhteystyyppiä, voidaan palata takaisin lähtöpisteeseen jonkin muun kuin sen yhteystyypin kautta, josta kierros alkoi. Tätä on havainnollistettu alemmassa kuvassa sinisillä nuolilla. Yksilötyyppiin 3 ei kohdistu kiertoa.
 

10.6.1 KIERTO-ONGELMA JA SEN RATKAISU
Yhteystyypeistä muodostuva kierto on ongelmallinen relaatiomallin kannalta. Tällainen rakenne ei takaa, että avainyhteydet ja eheyssäännöt pääsisivät "purkautumaan" missään vaiheessa. Tämä tarkoittaa, että esimerkiksi vieras-pääavain yhteydet tekevät silmukkarakenteesta sellaisen, että tietoja ei voida enää poistaa tai lisätä tauluihin: Tiedon eheys ei säilyisi, sillä poistettaessa/lisättäessä/muutettaessa arvoa taulussa A, tulisi samalla tapahtua muutoksia myös tauluissa B, C, D jne, joihin kohdistuvat muutokset taas tulisivat olla kierron takia yhtäaikaisia muissa tauluissa jne. jotta eheyssääntöjä ei rikottaisi. Relaatiomallissa muutokset voivat kerrallaan kohdistua kuitenkin vain yhteen tauluun. Rakenne on kuin kerä villalankaa, josta puuttuu pää, jonka avulla sitä voisi alkaa kiertämään auki.
Usein kuitenkin käsitekaavioon syntyy yhteyksiä tavalla, joka muodostaa kiertoa. Ratkaisuna on uudelleen miettiä yhteyksiä ja jos tarpeen, muodostaa kierron poistavia yhteysyksilötyyppejä. Alla on esitetty tällaisesta tilanteesta esimerkki. Joskus, tosin harvoin, voi kierron ratkaiseminen olla hankalaa, ja vaatia melkoista keplottelua ja uudelleenjärjestelyä. Kierron poistaminen on kuitenkin suositeltavaa, ja monesti välttämätöntä, ainakin tietokannan tulevan (sen kasvaessa) toimivuuden takaamiseksi.
 

10.6.2 KIERTO-ONGELMA, ESIMERKKI
Alla nähdään käsitemalli, johon on syntynyt kiertoa. On haluttu mallintaa tilanne, jossa Artisti voi liittyä sekä yksittäiseen raitaan/kappaleeseen (eri rooleissa: säveltäjä, sanoittaja, esittäjä), sekä liittyä albumiin sen kanteen/tietoihin merkittynä artistina. Artisti voi tarkoittaa niin yhtyettä kuin sooloartistia, tai mitä tahansa esittäjää tai esittäjä nimikettä.
Käsitemalli, jossa kiertoa esiintyy.

Käsitemallin neljä yksilötyyppiä muodostavat selvästi kierron. ArtistiKappale on malliin tuotu yhteysyksilötyyppi, joka purkaa Kappaleen ja Artistin M:N yhteyden.
Ratkaistaan kierto-ongelma luomalla yhteysyksilötyyppi:
 

 
 
Esitetty ratkaisu on vielä ylimalkainen: Riippuu kohdealueen vaatimuksista, miten yhteysyksilötyyppi toteutetaan. Jos äänitteellä voi olla artistina vain sellainen, joka esiintyy myös jollakin äänitteen kappaleella, niin jo tällainen rakenne riittää. AKA sisältää silloin yksinkertaisesti kolmoisavaimen, ja haluttu artisti vain tuodaan äänite tietueeseen vierasavaimena artistitiedoksi. On kuitenkin kiinnitettävä huomioita eheyssääntöihin ja mietittävä, milloin yhteys minkäkin yksilötyypin välillä saa vallita yhteysyksilötyypin kautta. Jos käytetään kolmoisavainta, ei voida liittää albumiin artistitietoa, ennen kuin kys. artisti ja jokin kys. albumilla oleva kappale on olemassa, ja näin kolmoisavainyhteys voi syntyä.
Jos tämä halutaan välttää, on luotava yhteysyksilötyypille oma, yksittäinen pääavainattribuutti (AKA_ID tms.), ja tuotava Kappale, Artisti ja Aanite tavallisina vierasavaimina, joille asetetaan toivotunlaiset eheyssäännöt. Tällöin voidaan myös tuoda käsitekaavioon alityyppejä yhteysyksilötypille. Näin voitaisiin erottaa, että artistilla voi olla suhde, joka liittyy kappaleeseen (esittäjä, säveltäjä, sanoittaja) tai toisaalta yhteys voi olla laatua "AlbuminEsittaja," eikä tällaiseen yhteyteen tarvitse (tai voi) liittyä kappaletta, vaan kappaleena on silloin aina standardi NULL arvo; tai taulussa on erillinen BOOLEAN tietotyyppinen attribuutti AaniteArtisti, jonka kohdalle tulee oletuksena epätosi, ja joka asetetaan arvoon tosi, mikäli esittäjä on (myös/vain) albumin esittäjä. Eheyssääntö voi edelleen kertoa, saako tietue, jossa on AlbumiEsittaja arvona tosi, liittyä myös johonkin kappaleeseen, vai tuleeko tällöin KappaleID olla jonkin vakioarvon mukainen tai standardi NULL.
Tällaisen yhteyden rakentamiseen voi siis liittyä monenlaisia mahdollisuuksia, joita on hyvä arvioida tarkkaan, jotta löytyy tarpeet täyttävä toteutustapa. Toisinaan voi olla paikallaan muuttaa rakennetta laajemminkin, tai jopa luoda tai poistaa yksilötyyppejä.
 

10.7 Käsitemallin kuvantamismenetelmistä
Käsitemallien kuvaamiseen on tällä kurssilla käytetty käsiteanalyysin mukaista lähestymistapaa noudattavaa, selkeästi yksilötyypeistä, yhteystyypeistä ja ominaisuustyypeistä (ja mahdollisista eheyssäännöistä) rakentuvaa mallia. Tällaisella mallilla on aiheeseen tutustuttaessa etunsa, sillä se mahdollisimman suoraan vastaa mallinnettavia käsitteitä. Lisäksi se on mahdollisimman yksinkertainen, eikä sisällä lainkaan turhaa tai ylimääräistä tietoa. Tällaisen mallin siirtäminen relaatiotietokannaksi on melko suoraviivaista, ja onnistuu ilman laajaa kokemusta.
Relaatiotietokantojen rakennetta on perinteisesti mallinnettu ns. ER-mallilla (Entity-Relationship model), josta on hiukan toisistaan poikkeavia variaatioita, mutta jonka toteutustapa on silti melko standardi. ER-malli ei ole relaatiotietokantariippuvainen, mutta on muodostunut sen yhteydessä paljon käytetetyksi. Myös UML-kaavioita (Unified Modeling Language) käytetään tietokantasuunnittelussa, joskin tämä mallinnustapa liitetään usein oliomalleihin, joiden ominaisuuksiin se pystyy vastaamaan parhaiten.
Ongelma ER-mallissa relaatiotietokantojen näkökulmasta on, että se on semanttisesti paljon rikkaampi kuin relaatiomalli. Tämä tarkoittaa, että ER-malli kykenee esittämään tietoa laajemmin kuin relaatiomalli. Ongelmaksi tulee, että ER-mallia ei usein voida siirtää sellaisenaan varsinaiseksi relaatiotietokannaksi; tämä ongelma on toki esiintynyt tällä kurssilla käytetyn käsitemallinkin yhteydessä, mutta paljon pienemmässä mittakaavassa. ER-mallista muunnos relaatiomalliin voi olla merkittävästi hankalampi ja osa sen sisältämästä tiedosta joudutaan yleensä hylkäämään.
Siksi on suositeltavaa relaatiomalliin ja tietokantoihin tutustuttaessa aloittaa kevyemmällä mallintamistekniikalla. Sellaiseksi sopii tälläkin kurssilla esitelty käsitemallinnus. Kokemuksen kartuttua voi olla tarpeen tutustua myös varsinaiseen ER-mallinnukseen, ja opetella sen käyttöä relaatiotietokantojen suunnittelussa. Juuri relaatiomalliin tutustuvan voi sen sijaan olla hyvin vaikea arvioida juuri tietyn ER-mallin semanttisen tiedon tasoa, sekä mitä sellaisia piirteitä se sisältää, jotka eivät ole relaatiomallin mukaisia, ja jotka on huomioitava ennen mallin siirtoa tietokannaksi.
Sama koskee myös UML-malleja, jotka ovat semanttisesti vielä ER-mallejakin rikkaampia. Toisaalta, kokemuksen myötä voidaan oppia käyttämään tätäkin tekniikkaa esim. alustavana, korkean tason mallintamismenetelmänä, kun hahmotetaan kohdealuetta ja siinä vallitsevia ilmiöitä ja niiden suhteita.
Tämän kurssin ja käytettävissä olevan tilan ja ajan puitteissa pysytään esitellyssä käsitemallinnuksessa, joka tarjoaa työkalut monipuolisten tietokantojen suunnitteluun ja tekee prosessista mahdollisimman helppoa ja lähestyttävää. Tämän kokemuksen puitteissa on myös helpompi myöhemmin lähestyä monipuolisempaa ER-mallinnusta.

11. Kooste- ja skalaarifunktioita
51. Tiedon johtaminen

11.1 Tiedon johtaminen
Olemme jo aiemmin käyttäneet matematiikka SELECT-kyselyissä. Operaattoreiden +, -, / ja * avullahan voitiin suorittaa laskutoimituksia WHERE-lausekkeen ehdossa. Voitiin esimerkiksi pyytää albumit, jotka olivat julkaistu tietyllä aikavälillä:
 
SELECT *
FROM Albumi
WHERE (2007 - Julkaistu) >= 10;
Sanomme, että tällainen kysely johtaa tietoa. Olemassa olevaa tietoa käytetään uudenlaisen informaation tuottamiseen. Saatu tieto on olemassa taulussa, mutta ei suoraan, valmiiksi annettuna.
Vaikka operaattoreilla ja niiden yhdistelmillä voidaan johtaa monipuolisesti tietoa, voi se käydä äkkiä hankalaksi. Toisaalta, tietyt hakutyypit, jotka perustuvat tiedon johtamiseen, ovat hyvin tavallisia. Niinpä SQL-kieli tarjoaa valmiita funktioita, jotka suorittavat tällaisia usein tarvittavia hakutoimintoja. Näitä ovat esimerkiksi keskiarvon tai summan laskeminen. Käymme tässä luvussa läpi näistä eniten käytetyt.
SQL-koostefunktioiden yleinen syntaksi SELECT-kyselyn yhteydessä on:
	SELECT funktio(kenttä) FROM Taulu
	 

11.1.1 SQL-FUNKTIO AVG: KESKIARVON LASKEMINEN
AVG laskee valitun attribuutin kenttien keskiarvon. Se jättää NULL-arvon sisältävät kentät huomioimatta.
Esimerkki:
	Käytössä on taulu Tuote, jossa on attribuutti Hinta. Se kertoo kunkin tuotteen hinnan. Haetaan kaikkien tuotteiden keskihinta.
	SELECT AVG(Hinta) FROM Tuote;
 
Tulos: kesiarvo on 8,683
        avg
--------------------
 8.6833333333333333
(1 row)
 
Esimerkki:
	Mikään ei estä tuomasta WHERE-lauseketta SELECTiin mukaan kun käytössä on SQL-funktioita. Lasketaan kaikkien tuotetyyppiä "Toimistotarvike" olevien tuotteiden keskihinta.
	SELECT AVG(Hinta)
	FROM Tuote
	WHERE Tuotetyyppi = 'Toimistotarvike';
 
Tulos:
        avg
--------------------
 2.8714285714285714
(1 row)
 

11.1.2 SQL-FUNKTIO MAX: ETSI KORKEIN ARVO
MAX funktiota käytetään attribuutin kentistä löytyvän korkeimman arvon etsimiseen. Se ei huomioi NULL arvoja.
Esimerkki:
	Mikä on korkein hinta joka taulusta Tuote löytyy?
	SELECT MAX(Hinta) FROM Tuote;
 
Tulos: korkein hinta on 30.0
  max
------
 30.0
(1 row)
 

11.1.3 SQL-FUNKTIO MIN: ETSI PIENIN ARVO
MIN funktiota käytetään attribuutin kentistä löytyvän pienimmän arvon etsimiseen. Se ei huomioi NULL-arvoja.
Esimerkki:
	Mikä on pienin hinta joka taulusta Tuote löytyy?
	SELECT MIN(Hinta) FROM Tuote;
 
Tulos: Matalin hinta on 0.30
  min
------
 0.30
(1 row)
 

11.1.4 SQL-FUNKTIO SUM: LASKE SUMMA
SUM-funktiota käytetään attribuutin kenttien arvojen yhteenlaskuun. On syytä muistaa, että kaikki laskutoimitukset ja lukuarvojen esitykset jotka tehdään liukuluvuilla, ovat epätarkkoja järjestelmän käyttämän esitystarkkuuden puitteissa.
Esimerkki:
	Mikä on hintojen summa?
	SELECT SUM(Hinta) FROM Tuote;
 
Tulos:
  sum
--------
 104.20
(1 row)
 

11.1.5 SQL-FUNKTIO ABS: ITSEISARVO
ABS-funktiota käytetään attribuutin kentässä olevan arvon itseisarvon laskemiseen.
Esimerkki:
	Mitkä ovat attribuutin "x-koordinaatti" lukuarvojen itseisarvot?
	SELECT ABS(x-koordinaatti) FROM Objekti;
 
Tulos: Lista koordinaattiarvojen itseisarvoista
  abs
-------
  1.00
  3.00
 15.42
  0.50
  1.70
  5.37
(6 rows)
 

11.1.6 SQL-FUNKTIO MOD: LASKE JAKOJÄÄNNÖS
MOD-funktiota käytetään laskemaan kahden luvun jakojäännös. Se on muotoa: MOD(luku1, luku2)
Esimerkki:
	Lasketaan jokaiselle x-koordinaattiarvolle jakojäännös, kun jakajana on y-koordinaatti.
	SELECT MOD(x-koordinaatti, y-koordinaatti) FROM Objekti;
 
Tulos:
  mod
-------
  1.00
 -3.00
  3.42
  0.50
 -1.70
  5.37
(6 rows)
 

11.1.7 SQL-FUNKTIO ROUND: LUKUARVOJEN PYÖRISTYS
Kun desimaali- eli liukulukuja ei tarvitse esittää koko tarkkuudella, voidaan ne esittää pyöristettynä. ROUND osaa pyöristää esitettävän arvon pyydetyllä tarkkuudella.
Esimerkki:
	Listataan tuotteiden hinnat yhden desimaalin tarkkuudella
	SELECT ROUND(Hinta, 1) FROM Tuote;
 
Tulos:
  round
-------
  10.0
  30.0
   9.9
  15.5
  18.7
   5.6
   2.0
   0.7
   4.2
   2.4
   5.0
   0.3
(12 rows)

12. Lisää tulosten järjestelystä
52. Koostefunktioiden tuloksista

12.1 Koostefunktioiden tuloksista
SQL:n koostefunktiot -- SUM, AVG, MAX jne -- laskevat tuloksen kaikista attribuutin kentistä, eli jokaiselta tietueelta, joka taulussa esiintyy. Tämä ei aina ole suotavaa, sillä voi tulla tarve laskea vaikkapa vain tietyn yhtyeen albumien kokonaiskesto. Avuksi on luotu GROUP BY -lauseke, jonka avulla voidaan tuloksia ryhmitellä ja toisaalta kohdistaa halutulla tavalla.
 

12.1.1 GROUP BY
Syntaksi:
	SELECT [attribuutti], FUNKTIO(attribuutti) FROM [Taulu] GROUP BY [attribuutti]
Esimerkki:
	Albumi taulun rakennetta on muutettu siten, että albumin kesto annetaan nyt kokonaislukuna, joka kertoo albumin keston minuuteissa.
	Pelkästään SQL-funktiota SUM käyttämällä emme saisi tulostettua erikseen kunkin yhtyeen albumien kestoja. Ottamalla avuksi GROUP BY, tämä onnistuu kätevästi:
	SELECT Esittaja, SUM(Kesto)
	   FROM Albumi 
	   GROUP BY Esittaja;
 
Tulos: Esittaja ja albumien kokonaiskesto minuutteina
   Esittaja    | sum
---------------+-----
 Pink Floyd    |  84
 The Beatles   | 176
 Rammstein     |  45
 Norah Jones   |  45
 Depeche Mode  |  52
 Eppu Normaali |
 CMX           | 104
 Air           |  43
(8 rows)
 
Toisaalta, voidaan käyttää lisänä jo tuttua ORDER BY -lausetta:
SELECT Esittaja, SUM(Kesto)
   FROM Albumi 
   GROUP BY Esittaja
   ORDER BY Esittaja;
 
Tulos:
   Esittaja    | sum
---------------+-----
 Air           |  43
 CMX           | 104
 Depeche Mode  |  52
 Eppu Normaali |
 Norah Jones   |  45
 Pink Floyd    |  84
 Rammstein     |  45
 The Beatles   | 211
(8 rows)
 
 
Esimerkki:
	Muistutuksena näytetään vielä ero kyselyyn ilman GROUP BY -komentoa. Kokonaiskesto saadaan kaikille tietueille tai tietyn ehdon mukaan, mutta ei yllä olevaa ryhmittelyä.
	SELECT SUM(Kesto)
	FROM Albumi
	WHERE Esittaja = 'The Beatles';
 
Tulos:
  sum
-----
 176
(1 row)
 

12.1.2 GROUP BY JA HAVING
HAVING-lausekkeen avulla voidaan muodostaa WHEREn kaltaisia ehtoja kyselyihin, jotka kohdistuvat jonkin koostefunktion tulokseen.
 
Esimerkki:
	Halutaan laatia kysely kuten edellisellä sivulla -- albumien kestot per esittäjä -- mutta siten että jätetään pois kokonaiskestot jotka jäävät alle 100 minuuttiin. HAVING antaa mahdollisuuden asettaa tämän ylimääräisen ehdon. Huomaa, miten HAVING ottaa koostefunktion ja muodostaa sen avulla ehdon.
	SELECT Esittaja, SUM(Kesto)
	   FROM Albumi 
	   GROUP BY Esittaja
	   HAVING SUM(Kesto) >= 100;
 
Tulos:
Esittaja   | sum
-------------+-----
 The Beatles | 176
 CMX         | 104
(2 rows)
 
Mikäli SELECTissä halutaan ehtona käyttää koostefunktiota, on se tehtävä HAVING lausekkeen avulla. WHERE ei voi käyttää ehtona koostefunktiota, ja tällaisen yrittäminen tuottaa virheilmoituksen.
Eli:
	SELECT Esittaja, SUM(Kesto)
	   FROM Albumi 
	   GROUP BY Esittaja
	   WHERE SUM(Kesto) >= 100;
 
palauttaisi virheen.
 

12.1.3 GROUP BY JA COUNT
COUNT-funktio on jo tuttu: Sen avullahan saatettiin laskea tietueiden lukumääriä jonkin attribuutin arvon perusteella. Esimerkiksi voitiin laskea kaikkien Beatles albumien lukumäärä:
	SELECT COUNT(*)
	   FROM Albumi
	   WHERE Esittaja = 'The Beatles';
joka antaisi tulokseksi count 3.
GROUP BY voidaan yhdistää COUNT-funktion kanssa tehokkaasti:
Esimerkki:
	Listataan kaikkien esittäjien albumien lukumäärät.
	SELECT Esittaja, COUNT(*)
	   FROM Albumi
	   GROUP BY Esittaja;
 
Tulos:
   Esittaja    | count
---------------+-------
 Pink Floyd    |     2
 The Beatles   |     3
 Rammstein     |     1
 Norah Jones   |     1
 Depeche Mode  |     1
 Eppu Normaali |     1
 CMX           |     2
 Air           |     1
(8 rows)


13. AS-sidesana
53. AS-sidesana käytöstä

13.1 AS-sidesana käytöstä
SQL-kielen AS-sanaa kutsutaan sidesanaksi. Sillä on lukuisia käyttökohteita, joista käymme tässä luvussa läpi tavallisimpia. Ensinnäkin, sen avulla voidaan kyselykohtaisesti uudelleen nimetä attribuutteja. Esimerkiksi listattaessa albumien kestoja, voitaisiin haluta käyttää attribuutin nimen "Kesto" sijasta nimikettä "AlbuminPituus" tms. joka sopii paremmin kyselyn tulosten tarkasteluun silloin kun kaikki osapuolet eivät tunne tarkkaan tietokannan rakennetta ja mitä jokin tietty ytimekäs attribuutin nimi tarkoittaa.
Kyselyssä voidaan AS sanana avulla myös lisätä tulosten joukkoon selventäviä tekstejä, jotka helpottavat tulosteen ymmärtämistä. Voidaan myös uudelleen nimetä laskutoimitusten tuloksina saatuja kenttiä selvemmin kertomaan mitä ne edustavat. Lopuksi tarkastellaan vielä erityisen COALESCE-funktion käyttöä AS-liitesanan kanssa, kun halutaan NULL-arvot korvata esimerkiksi selittävällä tekstillä.
 

13.1.1 AS JA ATTRIBUUTIN UUDELLEENNIMEÄMINEN
Kun taulun attribuutin nimi ei ole kyselyn tulosten kannalta paras mahdollinen, voidaan se uudelleen nimetä kyselykohtaisesti AS sanalla.
Esimerkki:
	Tulostetaan albumien tiedot. Nimetään "Kesto" uudelleen "Albumin pituus, minuuttia" ja nimetään "Julkaistu" uudelleen "Julkaisuvuosi". Lisätään "Esittaja":n ääkköset.
	SELECT Nimi, Esittaja AS Esittäjä, Julkaistu AS Julkaisuvuosi, Kesto AS "Albumin pituus, minuuttia"
	   FROM Albumi
	   ORDER BY Esittaja", Nimi;
 
Tulos:
	Nähdään, että AS mahdollistaa mm. välilyöntien käytön nimikkeissä ja skandinaaviset merkit saadaan tulostettua ilman ongelmia.
	           Nimi            |   Esittäjä    | Julkaisuvuosi | Albumin pituus, minuuttia
	---------------------------+---------------+---------------+---------------------------
	 Talkie Walkie             | Air           |          2002 |                        43
	 Aura                      | CMX           |          1994 |                        56
	 Vainajala                 | CMX           |          1998 |                        48
	 Playing the Angel         | Depeche Mode  |          2005 |                        52
	 Valkoinen kupla           | Eppu Normaali |          1986 |
	 Come Away With Me         | Norah Jones   |          2002 |                        45
	 Animals                   | Pink Floyd    |          1977 |                        41
	 The Dark Side of the Moon | Pink Floyd    |          1973 |                        43
	 Mutter                    | Rammstein     |          2001 |                        45
	 Abbey Road                | The Beatles   |          1969 |                        47
	 Revolver                  | The Beatles   |          1966 |                        35
	 Rubber Soul               | The Beatles   |          1965 |                        36
	 The Beatles               | The Beatles   |          1968 |                        93
	(13 rows)
 
 

13.1.2 AS JA TEKSTIN LISÄÄMINEN KYSELYN TULOSLISTAUKSEEN.
Aina ei pelkkä attribuuttien uudelleennimeäminen riitä parhaan mahdollisen tulosteen aikaansaamiseen. Tällöin voi olla hyödyksi lisätä selventävä "apu-attribuutti" kyselyn tulokseen jonka sisältämä teksti auttaa hahmottamaan tulosteen paremmin tai estämään vääränlaisen tulkinnan.
Esimerkki:
	Lisätään tekstiä kyselyyn joka tuottaa tiedot albumin julkaisseesta yhtyeestä ja julkaisuvuodesta. Luodaan seuraavanlainen tuloste: [Esittaja] julkaisi vuonna [Julkaistu] albumin [Nimi]. Järjestetään julkaisuvuoden mukaan.
	SELECT Esittaja, 'julkaisi vuonna' AS "Selite1", Julkaistu, 'albumin' AS "Selite2", Nimi
	   FROM Albumi
	   ORDER BY Julkaistu;
 
Tulos:
	Tulosteessa käytettävien apuattribuuttien arvot annettiin SELECTille '  ' merkkien sisällä, kun taas itse attribuutin "  " merkkien sisällä.
	
	   Esittaja    |     Selite1     | Julkaistu | Selite2 |           Nimi
	---------------+-----------------+-----------+---------+---------------------------
	 The Beatles   | julkaisi vuonna |      1965 | albumin | Rubber Soul
	 The Beatles   | julkaisi vuonna |      1966 | albumin | Revolver
	 The Beatles   | julkaisi vuonna |      1968 | albumin | The Beatles
	 The Beatles   | julkaisi vuonna |      1969 | albumin | Abbey Road
	 Pink Floyd    | julkaisi vuonna |      1973 | albumin | The Dark Side of the Moon
	 Pink Floyd    | julkaisi vuonna |      1977 | albumin | Animals
	 Eppu Normaali | julkaisi vuonna |      1986 | albumin | Valkoinen kupla
	 CMX           | julkaisi vuonna |      1994 | albumin | Aura
	 CMX           | julkaisi vuonna |      1998 | albumin | Vainajala
	 Rammstein     | julkaisi vuonna |      2001 | albumin | Mutter
	 Norah Jones   | julkaisi vuonna |      2002 | albumin | Come Away With Me
	 Air           | julkaisi vuonna |      2002 | albumin | Talkie Walkie
	 Depeche Mode  | julkaisi vuonna |      2005 | albumin | Playing the Angel
	(13 rows)
 
 

13.1.3 LASKUTOIMITUSTEN JA FUNKTIOIDEN TULOSTEN UUDELLEEN NIMEÄMINEN
Kahdessa edellisessä luvussa on tarkasteltu COUNT ja koostefunktioiden käyttöä. Erilaisten funktioiden ja matemaattisten lausekkeiden tuloksia voidaan AS-sanan avulla uudelleennimetä paremmin kuvaamaan niiden roolia kyselyn tuloksen kannalta.
Alla nähdään muistin virkistykseksi miten COUNT-funktiolla voitiin tulostaa albumien lukumäärä per esittäjä.
Esimerkki:
	Listataan kaikkien esittäjien albumien lukumäärät.
	SELECT Esittaja, COUNT(*)
	   FROM Albumi
	   GROUP BY Esittaja;
 
Tulos:
   Esittaja    | count
---------------+-------
 Pink Floyd    |     2
 The Beatles   |     4
 Rammstein     |     1
 Norah Jones   |     1
 Depeche Mode  |     1
 Eppu Normaali |     1
 CMX           |     2
 Air           |     1
(8 rows)
 
Tuloste ei ole selvin mahdollinen. Mitä "count" tarkoittaa? Sehän on albumien lukumäärä. Joten käytetään AS-sanaa ja kerrotaan tämä kyselyssä uudelleen nimeämällä COUNT-funktion tulos.
Esimerkki:
	Listataan kaikkien esittäjien albumien lukumäärät. Nimetään COUNT-funktion tulos seuraavasti: "Albumien lukumäärä."
	SELECT Esittaja, COUNT(*) AS "Albumien lukumäärä"
	   FROM Albumi
	   GROUP BY Esittaja;
 
Tulos:
   Esittaja    | Albumien lukumäärä
---------------+--------------------
 Pink Floyd    |                  2
 The Beatles   |                  4
 Rammstein     |                  1
 Norah Jones   |                  1
 Depeche Mode  |                  1
 Eppu Normaali |                  1
 CMX           |                  2
 Air           |                  1
(8 rows)
 
AS toimii yhtäläisesti niin funktioiden kuin laskutoimitustenkin yhteydessä.
Esimerkki:
	Laaditaan kysely, joka kertoo kuinka monta vuotta sitten albumi on julkaistu. Oletetaan että nyt on vuosi 2007. Järjestetään julkaisusta kuluneen ajan mukaan.
	SELECT Nimi, 'julkaistiin' AS "Selite1", (2007 - Julkaistu) AS "Selite2", 'vuotta sitten' AS "Selite3"
	   FROM Albumi
	   ORDER BY Selite2;
 
Tulos:
           Nimi            |   Selite1   | Selite2 |    Selite3
---------------------------+-------------+---------+---------------
 Playing the Angel         | julkaistiin |       2 | vuotta sitten
 Come Away With Me         | julkaistiin |       5 | vuotta sitten
 Talkie Walkie             | julkaistiin |       5 | vuotta sitten
 Mutter                    | julkaistiin |       6 | vuotta sitten
 Vainajala                 | julkaistiin |       9 | vuotta sitten
 Aura                      | julkaistiin |      13 | vuotta sitten
 Valkoinen kupla           | julkaistiin |      21 | vuotta sitten
 Animals                   | julkaistiin |      30 | vuotta sitten
 The Dark Side of the Moon | julkaistiin |      34 | vuotta sitten
 Abbey Road                | julkaistiin |      38 | vuotta sitten
 The Beatles               | julkaistiin |      39 | vuotta sitten
 Revolver                  | julkaistiin |      41 | vuotta sitten
 Rubber Soul               | julkaistiin |      42 | vuotta sitten
(13 rows)
 

13.1.4 AS JA COALESCE-FUNKTION KÄYTTÖ
Kun kyselyn tulosteessa halutaan välttää NULL-arvojen esittäminen, voidaan käyttää COALESCE-funktiota AS-sanan ohessa. Näin voidaan antaa NULL arvon omaaville kentille tilapäinen arvo, joka tulostetaan NULL (=tyhjä) arvon sijasta.
Esimerkki:
	Lainaaja taulussa attribuutti Email saattoi sisältää myös NULL-arvoja. Jos nyt pyydetään yksinkertaisesti listaus lainaajista, nähdään että parilla lainaajalla ei ole sähköpostiosoitetta annettu.
	SELECT Etunimi, Sukunimi, PuhNro, Email
	   FROM Lainaaja;
 
Tulos:
	Pari sähköpostiosoitetta sisältää NULL arvon.
	
	Etunimi  |  Sukunimi   |   PuhNro    |            Email
	---------+-------------+-------------+-----------------------------
	 Satu    | Tahvanainen | 0412211331  |
	 Matti   | Meikäläinen | 0401239876  | matti.meikalainen@sposti.fi
	 Esko    | Tahvanainen | 0503787843  | esko.tahvanainen@email.com
	 Maija   | Meikäläinen | 0601298347  | maija@sposti.fi
	 Antero  | Saarinen    | 012-1298127 | antero@posti.com
	 Liisa   | Lahtela     | 051-4455222 |
	(6 rows)

Halutaan, että tyhjiä arvoja ei tulostu. Laaditaan uusi kysely. Käytetään COALESCE funktiota muodossa: COALESCE(attribuutti, 'NULL-arvon korvaava teksti')
 
Esimerkki:
	Laaditaan lainaajat tulostava kysely, jossa korvataan mahdollinen NULL arvo sähköpostiosoitteelle tekstillä "ei sähköpostiosoitetta." Käytetään COALESCE  funktiota tämän saavuttamiseksi. COALESCElle on annettava AS-sanalla uusi nimi (alla "Email"), ellei haluta sähköpostiattribuutin nimeksi "coalesce."
	SELECT Etunimi, Sukunimi, PuhNro,
	   COALESCE (Email, 'ei sähköpostiosoitetta') AS Email
	   FROM Lainaaja
	   ORDER BY Sukunimi, Etunimi;
 
Tulos:
	
	Etunimi  |  Sukunimi   |   PuhNro    |            Email
	---------+-------------+-------------+-----------------------------
	 Liisa   | Lahtela     | 051-4455222 | ei sähköpostiosoitetta
	 Maija   | Meikäläinen | 0601298347  | maija@sposti.fi
	 Matti   | Meikäläinen | 0401239876  | matti.meikalainen@sposti.fi
	 Antero  | Saarinen    | 012-1298127 | antero@posti.com
	 Esko    | Tahvanainen | 0503787843  | esko.tahvanainen@email.com
	 Satu    | Tahvanainen | 0412211331  | ei sähköpostiosoitetta
	(6 rows)


14. Taulujen väliset liitokset
54. Useisiin tauluihin kohdistuvista kyselyistä
55. INNER JOIN
56. OUTER JOIN
57. Muut OUTER JOIN liitokset
58. WHERE ehdon käyttö liitoksissa

14.1 Useisiin tauluihin kohdistuvista kyselyistä
Tähän saakka olemme laatineet SQL-kyselyjä jotka ovat kohdistuneet kerrallaan yksittäiseen tauluun. Meidän ei ole tarvinnut pohtia taulujen välisiä avainyhteyksiä kyselyjä laatiessamme.
Jotta tietokantaa voitaisiin hyödyntää täysipainoisesti, tulee väistämättä eteen tarve koostaa tietoa eri tauluista. Itse asiassa, kuten relaatiomallin perusteiden yhteydessä jo puhuttiin, tämähän on mallin idea: Tieto on hajautettu kompakteihin tauluihin, joista kukin esittää vain 100% yhteenkuuluvaa tietoa, ja kaikki mitä ei väistämättä tarvita taulun tietueissa on saatavissa jostakin muusta taulusta. Tietokokonaisuuden aikaansaamiseksi joudutaan tiedon "murusia" poimimaan useista eri tauluista, kunkin taulun vastuulla ollen vain tietyn murusen "tietäminen."
Tässä luvussa nähdään, miten SQL-kielen JOIN lausekkeilla voidaan kyselyssä yhdistellä tietoja eri tauluista jo aiemmin laadittuja avainyhteyksiä hyväksikäyttäen. Jos tuntuu, että avainyhteydet eivät ole vielä täysin tuttuja tai muistissa, on suositeltavaa käydä vielä läpi relaatiomallia ja suunnittelua käsittelevät luvut (2 ja 3, sekä 9 ja 10)
 

14.1.1 JOIN-LAUSEKE
SQL-kielen JOIN lausekkeita on useita erilaisia. Jokainen niistä osaa yhdistää tietoa hiukan eri tavoin. Käymme tässä luvussa ne läpi aloittaen INNER JOIN lausekkeesta ja käsittelemällä tämän jälkeen erilaiset OUTER JOIN lausekkeet.
 

14.1.2 INNER JOIN LIITOS
Voimme käyttää INNER JOIN lauseketta yhdistämään kahden taulun attribuuttien arvoalueet siten, että vain ne kentät, joiden arvo esiintyy molemmissa tauluissa, jäävät kyselyyn.
Alla oleva diagrammi esittää kahden attribuutin arvoalueita INNER JOINin näkökulmasta. Attribuutit ovat eri tauluista. Liitoksessa huomioidaan vain ne tietueparit, joissa on sama arvo kummassakin taulussa.
 

 
Pääavain-vierasavain yhteyksissä on yleensä näin:
 


Tavallisestihan vierasavain ei voi sisältää arvoja joita ei olisi pääavainarvoina: Muutenhan vierasavain yhdistyisi pääavaimeen jota ei ole. Sen sijaan pääavaimessa voi hyvinkin olla paljon arvoja, joita ei löydy vierasavainarvoina toisesta taulusta. Esimerkiksi Albumi - Lainaus: Albumissa on AlbumiID arvoja joita ei ole Lainaus taulussa. Kuitenkin, ja näin on oltava, kaikki Lainaus taulun vierasavain AlbumiID:t löytyvät Albumi taulusta pääavainarvoina.

 

14.2 INNER JOIN
INNER JOIN jättää kyselyyn siis vain arvot jotka ovat yhteisiä molemmille attribuuteille, jos yhdistelmässä on kaksi taulua, tai kaikille attribuuteille, jos mukaan otetaan enemmän attribuutteja eri tauluista.

 

14.2.1 INNER JOIN JA KAHDEN TAULUN LIITOS
Syntaksi:
	[taulu1] INNER JOIN [taulu2] ON [attribuutti1] = [attribuutti2]
Esimerkki:
	Halutaan tietää, ketkä ovat lainanneet albumeja.
	Muistutetaan mieleen Lainaukset tietokantamme rakenne: Lainaus taulu yhdisti Albumin ja Lainaajaan. Lainauksessa on kaksoispääavain, jonka osat ovat samalla vierasavaimia.
	
	
	Jotta voimme tietää, ketkä ovat lainanneet albumeja, on laadittava kysely, joka etsii ne LainaajaID arvot jotka esiintyvät sekä Lainaus että Lainaaja taulussa. Jättämällä pois ne LainaajaID:t, joita ei esiinny Lainaus taulussa, jätämme pois ne, jotka eivät ole lainanneet. Tarvitaan siis INNER JOINin käyttöä. Miksi juuri INNER JOIN? Koska a) kyselyn on kohdistuttava useampaan kuin yhteen tauluun, ja b) tarvitsemme juuri ne arvot jotka ovat samat molemmissa liitoksen attribuuteista. Muita arvoja emme saa ottaa mukaan.
	INNER JOIN kysely:
	SELECT  Etunimi, Sukunimi, AlbumiID
	   FROM Lainaaja
	   INNER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID;
 
Huomaa piste notaation käyttö: Viittaamme haluttuun attribuuttiin halutussa taulussa käyttämällä notaatiota taulu.attribuutti. Nähdään myös, että sanaa ON käytetään ilmoittamaan avainattribuutit, joiden kautta yhteys muodostuu.
 
 
Tulos:
	Kuka on lainannut, ja mitä.
	
	Etunimi  |  Sukunimi   | AlbumiID
	---------+-------------+----------
	 Matti   | Meikäläinen |        1
	 Antero  | Saarinen    |       10
	 Antero  | Saarinen    |       11
	 Esko    | Tahvanainen |        5
	(4 rows)

Katsotaan vielä miltä Lainaus taulu näytti kyselyhetkellä, vrt. rakennekuva ylempänä. Nähdään, että vain ne Lainaajat tulostettiin, jotka todellakin ovat lainanneet jotakin. Muita ei.
	
	Lainaus taulun sisältö:
	
	AlbumiID  | LainaajaID |    Pvm
	----------+------------+------------
	        1 |          3 | 2007-06-30
	       10 |          5 | 2007-04-12
	       11 |          5 | 2007-04-12
	        5 |          1 | 2006-12-07
	(4 rows)

HUOM:
Taulu.Attribuutti merkintätapaa on käytettävä aina, jos ei ole selvää, minkä taulun attribuuttia tarkoitetaan. Jos on kaksi taulua, joissa on samannimisiä attribuutteja, ja piste notaatiota ei käytetä kertomaan minkä taulun attribuuttiin viitataan, antaa TKHJ virheilmoituksen:

ERROR: column reference "AlbumiID" is ambiguous.


14.2.2 INNER JOIN JA USEIDEN TAULUJEN LIITOKSET
Edellä käytimme kyselyssä hyväksi tietoa kahdesta eri taulusta. Näin saatiin tietää, ketkä lainaajat ovat lainanneet ja mitä. Mutta entä jos halutaan AlbumiID:n sijaan tietää, minkä nimisen albumin lainaaja on lainannut? Tiedon koostaminen kahdesta taulusta ei enää riitä, sillä Lainaus taulu tietää vain AlbumiID:n -- niin kuin sen kuuluukin. Ratkaisu on ulottaa kysely koskemaan myös Albumi taulua edelleen avainyhteyttä hyväksi käyttäen.
Täytyy siis tuntea, miten kysely kohdistuu useampaan kuin kahteen tauluun kerrallaan.
Esimerkki:
	Halutaan tietää, ketkä ovat lainanneet albumeja ja mikä on kunkin lainatun albumin nimi.
	Tarkastellaan jälleen taulujen rakennetta:
	
	Käytämme INNER JOINia, mutta sidomme yhteen kaikkien kolmen taulun arvoalueet avainyhteyksien kautta. Näin Albumi tauluun jäävät kyselyn näkökulmasta vain tietueet joiden AlbumiID esiintyy Lainaus taulussa. Lainaus ja Lainaaja tauluissa taas esintyy vain molemmissa läsnä olevat LainaajaID:t. Tuloksena vain ne albumit jäävät, joita on lainattu, sekä vain ne lainaajat jäävät, jotka ovat lainanneet. 
	INNER JOIN kysely:
	SELECT Lainaaja.Etunimi, Lainaaja.Sukunimi, Albumi.Nimi AS "Albumi"
	   FROM (Lainaaja INNER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID)
	   INNER JOIN Albumi ON Albumi.AlbumiID = Lainaus.AlbumiID;

Albumi.Nimi on uudelleennimetty AS-sanalla Albumiksi.
Kysely voi vaikuttaa monimutkaiselta, mutta itse asiassa sen rakenne on täysin sama kuin edellisen sivun kaksi taulua yhdistävällä kyselyllä. Siinä missä edellisessä FROM oli toinen tauluista, on FROM nyt yksinkertaisesti toinen osa liitoksesta. Idea on täysin sama: Nyt vain kohteena on liitoksen synnyttämä taulu, jolla on INNER JOIN operaation mukaiset tietueet.
Tulos:
	
	Etunimi  |  Sukunimi   |      Albumi
	---------+-------------+-------------------
	 Matti   | Meikäläinen | Come Away With Me
	 Antero  | Saarinen    | The Beatles
	 Antero  | Saarinen    | Abbey Road
	 Esko    | Tahvanainen | Mutter


Katsotaan vielä miltä Albumi taulu näytti kyselyhetkellä, vrt. rakennekuva ylempänä ja edellisen sivun Lainaus taulun tuloste.
	
	Albumi taulun sisältö:
	
	 AlbumiID |           Nimi            |   Esittaja    | Julkaistu | Kesto
	----------+---------------------------+---------------+-----------+-------
	        1 | Come Away With Me         | Norah Jones   |      2002 |    45
	        2 | The Dark Side of the Moon | Pink Floyd    |      1973 |    43
	        3 | Talkie Walkie             | Air           |      2002 |    43
	        4 | Playing the Angel         | Depeche Mode  |      2005 |    52
	        5 | Mutter                    | Rammstein     |      2001 |    45
	        6 | Valkoinen kupla           | Eppu Normaali |      1986 |
	        7 | Aura                      | CMX           |      1994 |    56
	        8 | Animals                   | Pink Floyd    |      1977 |    41
	        9 | Vainajala                 | CMX           |      1998 |    48
	       10 | The Beatles               | The Beatles   |      1968 |    93
	       11 | Abbey Road                | The Beatles   |      1969 |    47
	       12 | Rubber Soul               | The Beatles   |      1965 |    36
	       13 | Revolver                  | The Beatles   |      1966 |    35
	(13 rows)
 

14.2.3 PARANTELUA
Voidaan vielä parantaa kyselyä lisäämällä aiemmin opitun perusteella apuattribuutteja tulostukseen selittämään, mistä listauksessa on kyse. Otetaan vielä mukaan tieto lainauspäivästä.
 
SELECT Lainaaja.Etunimi, Lainaaja.Sukunimi, 'on lainannut' AS "Selite1", Lainaus.Pvm, 'albumin' AS "Selite2", Albumi.Nimi AS "Albumi"
   FROM (Lainaaja INNER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID)
   INNER JOIN Albumi ON Albumi.AlbumiID = Lainaus.AlbumiID
   ORDER BY Lainaaja.Sukunimi, Lainaaja.Etunimi;
 
Tulos:
	
	Etunimi  |  Sukunimi   |   Selite1    |    Pvm     | Selite2 |      Albumi
	---------+-------------+--------------+------------+---------+-------------------
	 Matti   | Meikäläinen | on lainannut | 2007-06-30 | albumin | Come Away With Me
	 Antero  | Saarinen    | on lainannut | 2007-04-12 | albumin | The Beatles
	 Antero  | Saarinen    | on lainannut | 2007-04-12 | albumin | Abbey Road
	 Esko    | Tahvanainen | on lainannut | 2006-12-07 | albumin | Mutter
	(4 rows)


14.3 OUTER JOIN
INNER JOINin ohella tarjoaa SQL myös OUTER JOIN liitoksia. OUTER JOIN voi edelleen olla LEFT tai RIGHT tyyppiä. Alla on INNER JOINIa vastaava esitys OUTER JOIN liitoksesta.



Kun inner join yhdisti kaikista tauluista vain yhtenevät arvot omaavat tietueet, voidaan outer joinin avulla laajentaa tällaista liitosta niin, että taulun 1 suhteen sallitaan kaikki arvot, ja vain taulusta 2 seulotaan pois arvot joita ei esiinnyt taulussa 1. Outer join on vähän kuin puolittainen inner join.
Milloin tällainen SQL-kielen OUTER JOIN lauseke olisi sitten tarpeen? Jos laadittaisiin aluksi luvun ensimmäisen INNER JOIN esimerkin kaltainen kysely: "Listaa Lainaajat, jotka ovat lainanneet, ja minkä AlbumiID:n on lainannut", eli ketkä ovat lainanneet ja mitä. Nyt jos kyselyä muutettaisiin niin, että haluttaisiin KAIKKI lainaajat, ja sen ohella merkintä lainatusta AlbumiID:stä niille jotka ovat lainanneet, tarvittaisiin OUTER JOIN. Nyt Lainaaja taulusta otetaan kaikki, ja sen ohella otetaan vain ne Lainaajat jotka esiintyvät Lainaus taulussa.
	
	
	
Tarvitaan tarkemmin sanottuna LEFT OUTER JOIN, sillä "seulova" tai "INNER JOIN" tyylinen liitos kohdistuu vasemmalle, kun taas oikeanpuoleinen taulu otetaan kokonaisuudessaan. Tehdään siis puolittainen INNER JOIN, ja vain vasemmalle.
 

14.3.1 OUTER JOIN ESIMERKKEJÄ
Esimerkki:
	Listaa kaikki lainaajat. Sen lisäksi listaa AlbumiID niille jotka ovat lainanneet albumin.
	LEFT OUTER JOIN kysely:
	SELECT Etunimi, Sukunimi, AlbumiID
	   FROM Lainaaja
	   LEFT OUTER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID;
 
Tulos:
	Nekin lainaajat mukana, jotka eivät ole lainanneet..
	
	Etunimi  |  Sukunimi   | AlbumiID
	---------+-------------+----------
	 Esko    | Tahvanainen |        5
	 Satu    | Tahvanainen |
	 Matti   | Meikäläinen |        1
	 Maija   | Meikäläinen |
	 Antero  | Saarinen    |       10
	 Antero  | Saarinen    |       11
	 Liisa   | Lahtela     |
	(7 rows)


Esimerkki:
	Voidaan kehittää kyselyä edelleen laskemalla lainattujen albumien lukumäärä niille, jotka ovat lainanneet. Käytetään vielä GROUP BY lauseketta järjestelemään tulokset.
	SELECT Etunimi, Sukunimi, COUNT(AlbumiID) AS "Albumeja Lainattu"
	   FROM Lainaaja
	   LEFT OUTER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID
	   GROUP BY Etunimi, Sukunimi
	   ORDER BY "Albumeja Lainattu" DESC, Sukunimi, Etunimi;
 
Tulos:
	
	Etunimi  |  Sukunimi   | Albumeja Lainattu
	---------+-------------+-------------------
	 Antero  | Saarinen    |                 2
	 Matti   | Meikäläinen |                 1
	 Esko    | Tahvanainen |                 1
	 Liisa   | Lahtela     |                 0
	 Maija   | Meikäläinen |                 0
	 Satu    | Tahvanainen |                 0
	(6 rows)


14.4 Muut OUTER JOIN liitokset
LEFT OUTER JOINin ohella SQL tukee myös RIGHT ja FULL OUTER JOIN liitoksia. RIGHT OUTER JOIN on vasemmalle suuntautuvan vastakohta: Siinä oikeanpuoleinen attribuutti seulotaan niin että vain vasemman kanssa yhtenevät arvot jäävät, ja vastaavasti vasemmalta otetaan kaikki arvot huomioon. Sitä käytetään kuten LEFT OUTER JOINia, mutta liitoksen "ota kaikki" ja "ota vain yhtenevät arvot" suunta vaihtuu.
FULL OUTER JOIN on kuten LEFT tai RIGHT tyyppinen OUTER JOIN, mutta niin, että kummastakin attribuutista, niin vasemmalta kuin oikealtakin, huomioidaan kaikki arvot. Minkäänlaista suodatusta ei tehdä kummallekaan puolelle. FULL tyyppinen liitos vain yhdistää attribuuttien arvoalueet ja kaikki mitä kummastakin löytyy on mukana.
 

14.4.1 RIGHT JA FULL OUTER JOIN LIITOSTEN DIAGRAMMIT
 

 
 





Koska INNER JOIN ja LEFT OUTER JOIN -määreiden ymmärtäminen ja hyödyntäminen tavallisesti riittää varsin pitkälle tietokantojen käytössä, emme syvenny RIGHT OUTER JOIN tai FULL OUTER JOIN määreisiin tässä esitettyä pidemmälle.

14.5 WHERE ehdon käyttö liitoksissa
Aivan kuten yksittäiseen tauluunkin kohdistuvassa kyselyssä, myös liitosten yhteydessä voidaan käyttää WHERE ehtoja. Katsomme vielä lopuksi yhden tällaisen esimerkin.
Esimerkki:
	Haluamme suorittaa kyselyn, joka listaa ne henklöt, jotka ovat lainanneet The Beatles yhtyeen albumeja. Jos henkilöllä on ollut useita lainauksia, pyydetään hänen nimensä vain kertaalleen.
	SELECT DISTINCT Lainaaja.Etunimi, Lainaaja.Sukunimi
	   FROM Lainaaja INNER JOIN Lainaus ON Lainaaja.LainaajaID = Lainaus.LainaajaID
	   INNER JOIN Albumi ON Albumi.AlbumiID = Lainaus.AlbumiID
	   WHERE Albumi.Esittaja = 'The Beatles';
 
Tulos:
	
	Etunimi  | Sukunimi
	---------+----------
	 Antero  | Saarinen
	(1 row)


15. Relaatioista ja näkymistä
59. Relaatiot ja taulut
60. Näkymät
61. Näkymän luominen ja poistaminen SQL-kielellä

Tarkastelemme tässä luvussa mitä tarkoitetaan eri tyyppisillä relaatioilla eli tauluilla, joita tietokannassa voi esiintyä. Katsomme myös, miten näkymiä, jotka ovat ns. johdettuja relaatioita, hyödynnetään SQL-kielen avulla.

15.1 Relaatiot ja taulut
Tähän saakka on termejä relaatio ja taulu käytetty synonyymeinä. Tämä on täysin hyväksyttävää, eikä normaalisti ole tarpeen pyrkiä luomaan näiden termien välille eroa; kumpikin tarkoittaa relaatiomallin mukaista, ja siten relaatiotietokannassa olemassa olevaa, taulua. Jos kuitenkaan halutaan tuoda esiin ero relaation ja taulun välille, voidaan se tiivistää seuraavasti: Taulu on esitys relaatiosta. Relaatio on relaatiomallin mukainen rakenne, jolla on relaatiomallin asettamat piirteet ja ominaisuudet. Taulu on relaatio, joka on oikeasti olemassa tietokananssa, eli rakenne, joka perustuu relaatioon. Taulu on myös esitetty jollakin järjestelmällisellä tavalla, esimerkiksi taulun attribuutit listataan vasemmalta oikealle tietyssä järjestyksessä, ja tämä järjestys on tärkeä taulua käytettäessä (vrt. INSERT INTO). Myös taulun tietueet listataan järjestettyinä. Relaation attribuutit eivöt ole järjestetty ja sen tietueet voivat esiintyä aivan missä järjestyksessä tahansa.
Taulu on relaatio esitettynä helpommin käytettävässä muodossa. Taulun attribuuttien järjestys esimerkiksi ei vaihtele ja sen tietueiden järjestykselle on aina jokin peruste, eikä niiden listaus ole satunnainen. (Vaikka siltä joissain tilanteissa voikin näyttää käyttäjälle, riippuen miten TKHJ milloinkin taulun tietueita järjestelee.)
 

15.1.1 PERUS- JA JOHDETUT RELAATIOT
Perusrelaatioita ovat käyttäjän CREATE TABLE komennolla luomat taulut. Ne ovat pysyviä ja aina olemassa tietokantaa käytettäessä kunnes ne erikseen poistetaan tai niiden määrityksiä muutetaan. Perustaulujen tietueet eivät muutu tietosisällöltään ellei niitä erikseen muuteta.
Kaikki tieto relaatiotietokannassa esitetään relaatioina. Tämä on tuttua jo relaatiomallin perusteista. Tämä myös tarkoittaa, että kaikki relaatiot eivät ole perusrelaatioita: Esimerkiksi SQL SELECT lauseella laadittu kysely esittää tietoja taulun muodossa, mutta tätä kyselyn tulostaulua ei löydy mistään tietokannasta: Sitä ei ole tallennettu minnekään. Saamme vain tulosteen, joka esittää kyselyn tuoksena luodun taulun sisällön. On selvää, ettei tämä taulu ole perusrelaatio.
Perusrelaatioiden ohella voidaankin puhua johdetuista relaatioista. Ne ovat tauluja, joiden rakenne ja tietueet johdetaan perustauluista esimerkiksi kyseoperaation tuloksena. Johdetut taulut ovat mielenkiintoisia, koska niiden avulla voidaan luoda näkymiä (views) tietokantaan.
15.1.2 NÄKYMÄ
Tavallisen kyselyn tulostaulu lakkaa olemasta yhtä nopeasti kuin se luotiinkin -- heti kun se on saatu tulostettua käyttäjälle. Näkymä sen sijaan on johdettu taulu -- eli kyselyn tulos -- joka jää pysyvästi tietokantaan perustaulujen oheen. Näkymä voidaan ajatella kyselynä, joka tallennetaan tietokantaan, ja jonka tulos on jatkuvasti nähtävissä taulun muodossa. Tämä taulu käyttäytyy lähes samoin kuin perustaulu.
Jatkamme esimerkillä alla.
 
 

15.2 Näkymät
Ennen kuin katsotaan miten näkymiä luodaan ja millaisia ominaisuuksia niillä on, tarkastellaan esimerkkinä luotua näkymää.

 

15.2.1 ESIMERKKINÄKYMÄ ESITTAJAALBUMI
Olemme aiemmin AS-sidesanaa käsittelevässä luvussa luoneet seuraavanlaisen kyselyn.
Tavallinen kysely:
SELECT Esittaja, 'julkaisi vuonna' AS "Selite1", Julkaistu, 'albumin' AS "Selite2", Nimi
   FROM Albumi;
 
Tulos:
	
	   Esittaja    |     Selite1     | Julkaistu | Selite2 |           Nimi
	---------------+-----------------+-----------+---------+---------------------------
	 Eppu Normaali | julkaisi vuonna |      1986 | albumin | Valkoinen kupla
	 Norah Jones   | julkaisi vuonna |      2002 | albumin | Come Away With Me
	 Pink Floyd    | julkaisi vuonna |      1973 | albumin | The Dark Side of the Moon
	 Air           | julkaisi vuonna |      2002 | albumin | Talkie Walkie
	 Rammstein     | julkaisi vuonna |      2001 | albumin | Mutter
	 Depeche Mode  | julkaisi vuonna |      2005 | albumin | Playing the Angel
	 CMX           | julkaisi vuonna |      1994 | albumin | Aura
	 Pink Floyd    | julkaisi vuonna |      1977 | albumin | Animals
	 CMX           | julkaisi vuonna |      1998 | albumin | Vainajala
	 The Beatles   | julkaisi vuonna |      1968 | albumin | The Beatles
	 The Beatles   | julkaisi vuonna |      1969 | albumin | Abbey Road
	 The Beatles   | julkaisi vuonna |      1965 | albumin | Rubber Soul
	(12 rows)
 
Kyselystä muodostetaan näkymä, jolle annetaan nimeksi EsittajaAlbumi. Näkymän luomisen jälkeen listataan tietokannan taulut. Saadaan alla olevan kaltainen listaus:
 
Tietokannan taulut:

Name           | Type  |
--------+---------------
Albumi         | table |
EsittajaAlbumi | view  |
Lainaaja       | table |
Lainaus        | table |
 
Tietokannassa on nyt näkymä EsittajaAlbumi. Tehdään yksinkertainen kokeilu:
Kysely: Mitä näkymä pitää sisällään?
SELECT * FROM EsittajaAlbumi;
 
Tulos: Meillä on nyt (pysyvä) taulu, joka esittää kyselyn tuloksen.
	
	   Esittaja    |     Selite1     | Julkaistu | Selite2 |           Nimi
	---------------+-----------------+-----------+---------+---------------------------
	 Eppu Normaali | julkaisi vuonna |      1986 | albumin | Valkoinen kupla
	 Norah Jones   | julkaisi vuonna |      2002 | albumin | Come Away With Me
	 Pink Floyd    | julkaisi vuonna |      1973 | albumin | The Dark Side of the Moon
	 Air           | julkaisi vuonna |      2002 | albumin | Talkie Walkie
	 Rammstein     | julkaisi vuonna |      2001 | albumin | Mutter
	 Depeche Mode  | julkaisi vuonna |      2005 | albumin | Playing the Angel
	 CMX           | julkaisi vuonna |      1994 | albumin | Aura
	 Pink Floyd    | julkaisi vuonna |      1977 | albumin | Animals
	 CMX           | julkaisi vuonna |      1998 | albumin | Vainajala
	 The Beatles   | julkaisi vuonna |      1968 | albumin | The Beatles
	 The Beatles   | julkaisi vuonna |      1969 | albumin | Abbey Road
	 The Beatles   | julkaisi vuonna |      1965 | albumin | Rubber Soul
	(12 rows)
 

15.2.2 NÄKYMÄN OINAISUUKSIA
Näkymä on siis taulu, joka sisältää kyselyn tuloksen. Tätä taulua voidaan käsitellä kuten perustauluja. Sitä vastaan voidaan suorittaa SELECT kyselyjä, ja sitä voidaan käyttää kyselyiden JOIN lausekkeissa kuin mitä tahansa taulua. On helppo kuvitella, että luomalla esimerkiksi kaksi näkymää ja laatimalla kyselyn näitä vastaan, voidaan suorittaa helposti varsin monimutkaisia ja vaativia kyselyjä, jotka yksittäisen SELECT lausekkeen varassa toteutettuna vaatisivat useita INNER tai OUTER JOIN lausekkeita ja muita määrityksiä.
Voimme nyt tehdä lisäyksen Albumit tauluun, ja katsoa, miten näkymä reagoi siihen.
Lisätään tietue tauluun Albumi:
INSERT INTO Albumi
   VALUES (13, 'Revolver', 'The Beatles', 35, 1966);
 
SELECT * FROM EsittajaAlbumi;
   Esittaja    |     Selite1     | Julkaistu | Selite2 |           Nimi
---------------+-----------------+-----------+---------+---------------------------
 Eppu Normaali | julkaisi vuonna |      1986 | albumin | Valkoinen kupla
 Norah Jones   | julkaisi vuonna |      2002 | albumin | Come Away With Me
 Pink Floyd    | julkaisi vuonna |      1973 | albumin | The Dark Side of the Moon
 Air           | julkaisi vuonna |      2002 | albumin | Talkie Walkie
 Rammstein     | julkaisi vuonna |      2001 | albumin | Mutter
 Depeche Mode  | julkaisi vuonna |      2005 | albumin | Playing the Angel
 CMX           | julkaisi vuonna |      1994 | albumin | Aura
 Pink Floyd    | julkaisi vuonna |      1977 | albumin | Animals
 CMX           | julkaisi vuonna |      1998 | albumin | Vainajala
 The Beatles   | julkaisi vuonna |      1968 | albumin | The Beatles
 The Beatles   | julkaisi vuonna |      1969 | albumin | Abbey Road
 The Beatles   | julkaisi vuonna |      1965 | albumin | Rubber Soul
 The Beatles   | julkaisi vuonna |      1966 | albumin | Revolver
(13 rows)
 
Näkymä siis heijastaa aina lähdetaulun/taulujen todellista tilaa. Se on aina "ajan tasalla."
 

15.2.3 MILLOIN KANNATTAA KÄYTTÄÄ NÄKYMÄÄ?
Yksinkertaisimmillaan näkymä voi tarjota jonkin usein tarvittavan kyselyn tuloksen kätevästi tauluna. Myös tilanteissa, joissa samantyyppisestä tiedosta joudutaan johtamaan kyselyitä, voidaan kyselyjä yksinkertaistaa käyttämällä pohjana näkymää joka on karsinut jo "turhia" tietoja pois ja lisännyt esimerkiksi selittäviä kenttiä.
Tietokannoissa, joissa on tarpeen asettaa tietoturva tai muista syistä käyttörajoituksia, voidaan näkymiä käyttää tarjoamaan käyttäjille juuri niitä tietoja, joihin heillä on pääsy/käyttöoikeus.  Esimerkiksi projektitietokannassa saattaisi projektiin osallistujalla olla aina olemassa näkymä joka esittäisi ProjektiOsallistujat taulusta (ja sen yhteystauluista) vai ne tietueet, jotka liittyvät samaan projektiin kuin missä työntekijä itsekin on. Näin työntekijä ei pääsisi käsiksi itse tauluun, vaan ainaostaan hänelle räätälöityyn näkymään, joka tarjoaa taulun tietoja tietyin ehdoin.
Näkymän kautta on myös mahdollista muuttaa tietoja. Se ei vain esitä kopiota lähdetaulujen tiedoista, vaan antaa itse asiassa näkymän suoraan alkuperäisiin tietueisiin. Jos näkymän tietueisiin tehdään muutoksia, välittyvät nämä muutokset lähdetauluun. Tällaista tarvitaan normaalisti vain, kun perustaulujen käyttöä on rajoitettu edellä kuvatulla tavalla. Emme siten tarkastele tietojen muutoksia näkymien kautta tässä luvussa tämän syvällisemmin. On kuitenkin hyvä muistaa, että esim. UPDATE lauseke suoritettuna näkymää vastaan vaikuttaa näkymän lähdetauluihin, ja näkymä vain päivittyy heijastamaan muuttuneita lähdetauluja. Näkymä itsessään ei sisällä tietoja; se on vain "filtteri" jonka läpi voidaan katsoa lähdetauluihin.
 

15.3 Näkymän luominen ja poistaminen SQL-kielellä
 
 

15.3.1 CREATE VIEW
Uusi näkymä voidaan luoda CREATE VIEW komennolla. Kysely, jonka mukainen esitys näkymään halutaan, annetaan näkymän nimen jälkeen suoraan sellaisenaan. CREATE VIEW komennossa ei tarvita sulkeita itse kyselylausekkeen ympärille, ja sen päättämiseen riittää puolipiste SELECT lausekkeen lopussa. Näkymän määrittävä kysely voi olla mielivaltaisen laaja.
 
Syntaksi:
	CREATE VIEW [näkymä] AS
	    SELECT lauseke;

Esimerkki:
	Luodaan näkymä, joka esittää Lainaajien tiedot, jättäen pois pääavainarvon.
	CREATE VIEW Lainaajat AS
	   SELECT Etunimi, Sukunimi, PuhNro, Email
	      FROM Lainaaja;
 
Tulos:
	
	Mikäli näkymän luonti onnistui, saadaan ilmoitus "CREATE VIEW" tai vastaava. Tarkasteltaessa tietokannan tauluja, nähdään näkymä listattuna.
	
	Näkymän sisältämät tietueet voidaan listata yksinkertaisella kyselyllä:
	
	SELECT * FROM Lainaajat
	   ORDER BY Sukunimi, Etunimi;
	
	Listaus:
	
	 Etunimi |  Sukunimi   |   PuhNro    |            Email
	---------+-------------+-------------+-----------------------------
	 Liisa   | Lahtela     | 051-4455222 |
	 Maija   | Meikäläinen | 0601298347  | maija@sposti.fi
	 Matti   | Meikäläinen | 0401239876  | matti.meikalainen@sposti.fi
	 Antero  | Saarinen    | 012-1298127 | antero@posti.com
	 Esko    | Tahvanainen | 0503787843  | esko.tahvanainen@email.com
	 Satu    | Tahvanainen | 0412211331  |
	(6 rows)
 
Koska näkymä voidaan määrittää SELECT kyselyn kautta, voi se perustua jo ennestään olemassaoleviin näkymiin. Katso kuitenkin DROP TABLE kohdan huomautus näkymien riippuvuussuhteista.
Esimerkki:
	Luodaan näkymä, joka hyödyntää jo aiemmin luotua näkymää Lainaajat.
	CREATE VIEW LainaajatNimella AS
	   SELECT Etunimi, Sukunimi
	      FROM Lainaajat
	      ORDER BY Sukunimi, Etunimi;
 
Tulos:
	
	SELECT * FROM LainaajatNimella
	
	Listaus:
	
	 Etunimi |  Sukunimi
	---------+-------------
	 Liisa   | Lahtela
	 Maija   | Meikäläinen
	 Matti   | Meikäläinen
	 Antero  | Saarinen
	 Esko    | Tahvanainen
	 Satu    | Tahvanainen
	(6 rows)

Joissakin tietokantajärjestelmissä kutsutaan johdettujen taulujen käyttöä kyselyn lähteenä alikyselyiden käyttämiseksi. Tällöin kyselyyn tuotava johdettu taulu on alikysely ja itse luotava kysely ns. pääkysely. Voidaan siten ajatella rakennettavan hierarkoita, joissa uudet kyselyt perustuvat alla oleviin kyselyihin. SQL-kielen kannalta termi alikysely on tällöin kuitenkin epätarkka, sillä myös SELECT kyselyistä voidaan rakentaa vastaavanlaisia hierarkioita. Tällöin kyselyyn upotetaan sisään toinen SELECT kysely, jonka palauttamaan arvoon tai arvoihin varsinainen pääkysely pohjautuu.
 

15.3.2 DROP VIEW
Kun näkymä halutaan poistaa, käytetään komentoa DROP VIEW.
Syntaksi:
	DROP VIEW [näkymä][RESTRICT|CASCADE]

RESTRICT / CASCADE voidaan halutessa jättää pois. Vain toinen määritteistä voi kerrallaan olla DROP VIEW komennossa.

15.3.3 DROP VIEW ILMAN RESTRICT/CASCADE MÄÄREITÄ
Jos DROP VIEW komennossa ei määritetä kuin poistettavan näkymän nimi, oletetaan, että RESTRICT määrite on annettu. Tällöin näkymä poistetaan vain, jos ei ole olemassa siihen kohdistuvia riippuvuuksia. Tämä tarkoittaa, että jos pyydetään poistamaan näkymä A, ja on olemassa näkymä B, jonka määrittelyssä käytettiin näkymää A lähteenä, antaa järjestelmä virheilmoituksen. Näkymä A voidaan poistaa vasta, kun ei ole olemassa näkymiä, jotka perustuisivat siihen. Ts. yksikään muu näkymä ei tarvitse poistettavaa näkymää. 
Loimme edellisellä sivulla näkymän LainaajatNimella, joka käytti näkymää Lainaajat (joka edelleen käytti taulua Lainaaja.) Voimme yrittää poistaa näkymän Lainaajat, johon perustuva näkymä on olemassa.
Esimerkki:
DROP VIEW Lainaajat;
 
Tulos: Poistaminen ei onnistu
	
	NOTICE:  rule _RETURN on view "LainaajatNimella" depends on view "Lainaajat"
	NOTICE:  view "LainaajatNimella" depends on rule _RETURN on view "LainaajatNimella"
	ERROR:  cannot drop view "Lainaajat" because other objects depend on it
	HINT:  Use DROP ... CASCADE to drop the dependent objects too.
 
Ratkaisuna on ensin poistaa näkymä LainaajatNimella, niin että poistettavaan näkymään ei enää kohdistu riippuvuuksia.
 

15.3.4 CASCADE
Määreellä DROP VIEW [näkymä] CASCADE voidaan pakottaa näkymän poisto. Tällöin mahdolliset riippuvuudet poistetaan. Jos näkymiä on useita ja ne riippuvat toisistaan, voi CASCADE muotoinen poisto joka kohdistuu yhteen näkymään poistaa jopa kaikki muut näkymät. Kannattaa siis olla tarkkana, mikä näkymä perustuu mihinkin, jos on rakentanut näkymiä niin että ne käyttävät lähteinä edellisiä. Siksi DROP VIEW onkin oletuksena RESTRICT, ei CASCADE, muotoinen.
Esimerkki:
DROP VIEW Lainaajat CASCADE;
 
Tulos: Pakotetaan näkymän ja riippuvuuksien poisto. Kumpikin näkymä on poistettu.
	
	NOTICE:  drop cascades to rule _RETURN on view "LainaajatNimella"
	NOTICE:  drop cascades to view "LainaajatNimella"
	DROP VIEW


16. Normalisointi
62. Mistä normalisoinnissa on kyse?
63. Mitä saadaan normalisoinnin tuloksena?
64. Funktionaalinen riippuvuus
65. Normaalimuodot
66. Toinen ja kolmas normaalimuoto
67. Normalisointiesimerkki
68. Normalisointiesimerkin ensimmäinen vaihe
69. Normalisointiesimerkin toinen vaihe
70. Normalisointiesimerkin kolmas vaihe

16.1 Mistä normalisoinnissa on kyse?
Normalisointi on käsiteanalyysin kaltainen suunnittelumenetelmä, joka on alunperin kehitetty juuri relaatiomallin tarpeisiin. Normalisointia voidaan käyttää tietokannan rakenteen luomiseen täysin tyhjästä aina valmiiseen rakennekuvaukseen saakka, aivan kuten olemme tehneet käsitemallin avulla.
Jos normalisointimenetelmiä käytetään täysimääräisenä suunnittelumenetelmistönä, on lähestymistapa tietokannan rakenteen muodostamiseen täysin päinvastainen kuin käsitemallissa: Normalisoinnissa aloitetaan tilanteesta jossa kaikki "yksilötyypit" (terminologia ei ole todellisuudessa 100% yhtenevä) ovat jo olemassa, ja tämän jälkeen normalisointiprosessi alkaa asteittain purkamaan tätä tietokokonaisuutta loogisesti yhteneviksi pienemmiksi kokonaisuuksiksi, päätyen lopulta tilanteeseen, jossa alun laaja tietokokonaisuus on pilkkoutunut ja samalla muotoutunut lukuisiksi loogisesti yhteenkuuluvista attribuuteista koostuviksi pienemmiksi yksilötyypeiksi, joista voidaan muodostaa relaatiotietokannan taulut. Samalla on luotu tauluille avainattribuutit.
Normalisointi on siis "ylhäältä alaspäin" etenevä menetelmä, kun taas käsitemalli muotoutuu päinvastoin: Ensin löydetään yksilötyyppejä ja yhteyksiä, joista alkaa koostua ja rakentua laajeneva, loogisesti yhtenäinen malli. Käsitemalli koostaa, kun taas normalisointi hajottaa, muokkaa ja pilkkoo rakenteita asteittain kohti normalisoitua tilaa.


16.1.1 NORMALISOINTI SUUNNITTELUN OSANA
Vaikka normalisointi soveltuukin relaatiotietokannan suunnitteluun, on melko harvinaista että tietokannan rakenne kehitettäisiin yksinomaan normalisointimenetelmillä. Normalisointia on jokseenkin hankalampi käyttää kuin käsitemalleja, ja laajoissa tietokannoissa se voi olla myös epäkäytännöllinen. Onkin tyypillistä, että normalisointi on mukana yhtenä vaiheena suunnitteluprosessissa, joka noudattaa käsiteanalyysiä. Kuten luvussa 10 mainittiin, on tavallista suorittaa käsiteanalyysin viimeisenä vaiheena käsitemallille ns. normalisointitarkistus.
Normalisoimalla luotu rakennemalli johtaa sellaisiin yksilötyyppeihin / tauluihin, jotka ovat normalisoituja. Palaamme tähän tuonnempana. Kun tiedetään, että käsitemallin avulla pitäisi aina päätyä myös normalisoituihin yksilötyyppeihin, voidaan normalisointitarkistusten avulla varmistua, että käsitemallin jokainen yksilötyyppi todellakin on normalisoitu. Jos näin on, ei normalisointi, joka yksilötyypille suoritetaan, muuta sitä enää lainkaan.
Voidaan siis sanoa, että käsitemallin avulla on helppoa löytää yksilötyypit, yhteystyypit ja ominaisuustyypit, ja luoda looginen rakenne näiden avulla. Normalisointi on hankalampi tämän tason luomiseen, mutta toisaalta, erittäin tehokas muokkaamaan jo olemassa olevat yksilötyypit takuuvarmasti normalisoituun muotoon -- käsitemallissa yksilötyypin normaalius jää puhtaasti käyttäjän päätelmien varaan. Yhdistämällä kumpikin menetelmistö voidaan luoda itse käsitemalli varsin helposti ja toisaalta varmistua rakenteen teknisestä oikeellisuudesta tekemällä sille normalisointi kun se on valmis. Jos kaikki on hyvin, ei normalisoinnin tulisi aiheuttaa malliin enää mitään muutoksia. Jos normalisointi taasen aiheuttaa muutoksia, osoittaa se, että suunnittelu ei ollut huolellinen ja mallia on korjattava normalisointitarkistuksen tuloksen osoittamalla tavalla.


16.2 Mitä saadaan normalisoinnin tuloksena?
Normalisoinnin tuloksena kaikki tietokannan taulut ovat normalisoituja. Tarkemmin sanottuna, ne ovat joko kolmannessa tai suuremmassa normaalimuodossa. Normaalimuotoja tunnetaan nykyisin kuuteen saakka, mutta yleensä riittää että taulut on saatettu kolmanteen tai korkeintaan neljänteen normaalimuotoon. Suuremmat normaalimuodot ovat kiinnostavia lähinnä erityistilanteissa ja hyvin vaativissa järjestelmissä, ja niiden käyttö kysyy jo asiantuntemusta joka ulottuu pitkälti yli tämän kurssin tarpeiden. Itse suunnitellulle pienelle tai keskisuurelle tietokannalle riittää vallan mainiosti kolmanteen normaalimuotoon ulotettu normalisointitarkistus.
Normalisoinnin tuloksena saadaan rakenne, jolle voidaan taata, että:
• Tietojen lisääminen, päivittäminen ja poistaminen on tehokasta ja yksinkertaista.
• Tietojen hakeminen on mahdollisimman yksinkertaista.
• Kun tietokantaan viedään tietoja tai olemassa olevaa tietoa muokataan, ei pitäisi syntyä ristiriitoja eikä tietoa hävitä. Toisaalta, tietokantaan ei myöskään pitäisi jäädä vanhaa, turhaa ja mihinkään liittymätöntä tietoa "roikkumaan" kun muita tietoja poistetaan.

Kuten olemme jo käsiteanalyysin yhteydessä nähneet, huonosti suunnitellun eli normalisoimattoman tietokannan kanssa yllä mainittuja piirteitä ei voida taata, ja tällaisissa tietokannoissa törmätään viimeistään pidemmän käytön myötä ongelmiin. (Muistellaan esimerkiksi tietokantaa Kalankasvattamot, joka ei todellakaan ollut normalisoitu!)
Hyvin tehdyn käsitemallin pitäisi johtaa normalisoituun tietokantaan. Mutta kuten on todettu, normalisointitarkistus on usein paikallaan, ihan vain varmuuden vuoksi.


16.3 Funktionaalinen riippuvuus
Jotta voidaan käsitellä normalisointitarkistuksessa vaadittavia ensimmäistä, toista ja kolmatta normaalimuotoa, on ensin esiteltävä funktionaalisen riippuvuuden käsite. Sitä tarvitaan arvioitaessa toista ja kolmatta normaalimuotoa.

16.3.1 TARKASTELUSSA OMINAISUUSTYYPIT
Funktionaalisia riippuvuuksia arvioitaessa keskitytään yksilötyypin ominaisuustyyppien välillä vallitseviin riippuvuussuhteisiin. Kyse ei ole siis käsitemallin yhteydessä puhuttavista yhteystyypeistä, jotka liittyvät kahden yksilötyypin väliseen suhteeseen. Funktionaaliset riippuvuudet vallitsevat yksilön ominaisuustyyppien välillä. Ominaisuustyypithän olivat valmiissa relaatiotietokannassa taulun attribuutteja, yksilötyypin ollessa itse taulu/relaatio.
Jos ominaisuustyyppien A ja B välillä vallitsee funktionaalinen riippuvuus, merkitään sitä seuraavanlaisella notaatiolla: A → B. Luetaan: "A nuoli B". Merkintä tarkoittaa, että B on funktionaalisesti riippuva A:sta. Huomaa järjestys: Se, johon nuoli osoittaa, on riippuvainen siitä, josta nuoli tulee.


16.3.2 FUNKTIONAALINEN RIIPPUVUUS MÄÄRITETTYNÄ
Funktionaalinen riippuvuus voi vallita kahden ominaisuustyypin tai ominaisuustyyppijoukon välillä. A ja B voivat koostua siten yhdestä tai useammasta ominaisuustyypistä. Milloin riippuvuus vallitsee? Alla annetaan määritelmä, jota selvitään vapaamuotoisemmin tämän jälkeen.

A ja B ovat ominaisuustyyppejä tai ominaisuustyyppiyhdistelmiä.
Jos jokaista A:n arvoa vastaa ainoastaan yksi B:n arvo, on B funktionaalisesti riippuva A:sta.
Merkitään A → B.
Jos A → B, on mahdollista olla myös B → A.
Funktionaalinen riippuvuus voi olla olemassa siis molempiin suuntiin. Voi olla että funktionaalista riippuvuutta ei ole lainkaan. Useiden ominaisuustyyppien välillä sitä ei ole mihinkään suuntaan.


16.3.3 FUNKTIONAALINEN RIIPPUVUUS KÄYTÄNNÖSSÄ
Mitä määritelmä käytännössä tarkoittaa? Tarkastellaan alla olevaa taulua, jossa on neljä mielivaltaisesti valittua attribuuttia: Kurssi, Opiskelija sekä A ja B.


Kurssi	Opiskelija	A	B	...	...
Tietokannat	Lahtinen Teppo	1	7		
	Niemi Marjut	1	7		

Matematiikka A
	Heikkinen Lasse	1	7		

Tietokannat
	Siimes Susanna	2	4		

Tietokannat
	Lehto Jyrki	2	4		

Matematiikka B
	Mikkonen Matilda	3	1		

Olio-ohjelmointi
	Varis Ville	5	8		

Olio-ohjelmointi



Tarkastellaan Attribuutteja Kurssi ja Opiskelija. Nähdään, että yhtä kurssia kohden voi esiintyä useita opiskelijoita. Esimerkiksi Tietokannat kurssia kohden jo heti alussa Lahtinen Teppo. Alempaa löytyy kuitenkin lisää opiskelijoita (kaksi muuta), jotka liittyvät tähän samaan kurssiin, tarkasteltaessa attribuuttien arvopareja. Matematiikka A kurssia kohden on vain yksi opiskelija, samoin Matematiikka B:tä kohden. Olio-ohjelmointiin liitty kaksi opiskelijaa. Nähdään myös selvästi, että yksittäistä Opiskelijaa vastaa aina yksi Kurssi arvo. Funktionaalisen riippuvuuden määritelmän perusteella voidaan siis lausua:
	Jokaista Opiskelijaa vastaa vain ja ainoastaan yksi Kurssi arvo. Täten Opiskelija → Kurssi: Kurssi on funktionaalisesti riippuva Opiskelijasta.
	Kurssia voi vastata useampi kuin yksi Opiskelija arvo. Opiskelija EI ole funktionaalisesti riippuva Kurssista.
Tarkastellaan vastaavasti attribuutteja A ja B. Nähdään, että kutakin A:n arvoa vastaa aina vain ja ainoastaan yksi B:n arvo. Toisaalta, myös jokaista B:n arvoa vastaa aina sama A:n arvo.
	Täten A → B ja B → A.
Entä onko attribuuttiparien välillä riippuvuutta? (Kurssi, Opiskelija) → (A, B), tai (A, B) → (Kurssi, Opiskelija)? On toiseen suuntaan: (Kurssi, Opiskelija) → (A, B)
Voitaisiin ajatella myös, että attribuuttiparien (Kurssi, Opiskelija) → (A, B) välillä on N:1 (monen suhde yhteen) asteinen suhde samalla tavoin kuin yhteystyyppien asteita hahmotettiin käsitemallin yhteydessä.

Tarkastellaan vielä attribuuttiparia C ja D:
	
	C	D
	 1	 R
	 2	 R
	 3	 P
	 1	 Q
C:n ja D:n välillä ei nyt ole funktionaalista riippuvuutta kumpaankaan suuntaan. Arvoa "1" vastaa arvo "R", mutta myös arvo "Q." Toisaalta, arvoa "R" vastaavat sekä arvot "1" että "2." Riippuvuuden määritelmä ei toteudu kumpaankaan suuntaan.


16.4 Normaalimuodot
Esittelemme seuraavaksi miten normalisointitarkistuksen yhteydessä käytettävät normaalimuodot määritetään. Tämän jälkeen katsotaan esimerkin avulla miten ne toimivat käytännössä ja miten normalisointi etenee näiden vaiheiden läpi.
Normalisointitarkistus etenee niin, että tarkistettava yksilötyyppi arvioidaan ensin ensimmäisen normaalimuodon perusteella. Jos se ei ole 1. normaalimuodossa, muutetaan sitä niin, että se on 1. normaalimuodossa. Tämän jälkeen arvioidaan sitä 2. normaalimuodon suhteen ja tehdään tarvittaessa muutokset. Näin käydään läpi kaikki kolme normaalimuotoa. Kun yksilötyypin todetaan olevan 3. normaalimuodossa, on sen tarkistus valmis.


16.4.1 ENSIMMÄINEN NORMAALIMUOTO
Mikäli yksilötyyppi on luotu käsitemallin kautta tai suoraan relaatiomallin tauluksi, pitäise sen olla jo 1. normaalimuodossa, koska tämän muodon vaatimukset ovat relaatiomallin näkökulmasta lähes itsestäänselviä.

Yksilötyyppi on ensimmäisessä normaalimuodossa, kun se ei sisällä muita kuin perusominaisuustyyppejä. Ts. sen ominaisuustyypit eivät sisällä koottuja arvoja.

16.4.2 KOOTUT ARVOT?
Tämä outo termi viittaa tilanteeseen, joka relaatiomallia tuntevalla voi tuntua jopa hölmöltä, sillä se ei ole relaatiomallissa mahdollinen. Juuri siksi 1. normaalimuoto tarkistaakin sen. Alla on annettu mielivaltainen taulu, jossa on esitetty koottuja arvoja. Tämä tarkoittaa, että yksittäisessä kentässä on enemmän kuin yksi tietoalkio. Relaatiomallin tauluissahan näin ei voinut olla. Vain yksi arvo per kenttä on mahdollinen. Nyt Asunnolle on merkitty useita asukkaita, eli AsukasID arvoja.


AsuntoID 	AsukasID	Muita attribuutteja...
1	1, 76, 3	
2	5, 20	
3	3	
4	7, 40, 2	
5	4	
6	11, 12	
7	35	



16.4.3 ENSIMMÄISEEN NORMAALIMUOTOON SAATTAMINEN.
Mikäli yksilötyyppi ei ole 1. normaalimuodossa, eli tällaisia monikertoja esiintyy, tulee ne poistaa. Ratkaisuna on purkaa yksilötyyppiä siten että nyt vallitseva informaatio säilyy, mutta monikertoja ei tarvitse käyttää. Tuloksena syntyy yleensä vähintään yksi uusi yksilötyyppi.
Yllä voitaisiin AsukasID irrottaa taulusta ja luoda uusi taulu, jossa olisi AsuntoID ja AsukasID attribuutit niin että AsukasID olisi pääavain. Yllä olevaan tauluun jäisi AsuntoID, mutta AsukasID poistuisi siitä ja olisi nyt läsnä vain uudessa taulussa joka luotiin rinnalle. Kun tällaisia muutosoperaatioita tehdään, katsotaan irrotettavat attribuutit funktionaalisten riippuvuuksien perusteella: Jos taulusta löytyisi attribuutteja, jotka olisivat riippuvia AsukasID:stä, otettaisiin ne mukaan uuteen tauluun johon AsukasID vietäisiin.
Nyt olisi monikertoja sisältänyt taulu muuttunut kahdeksi tauluksi: Vanhassa olisivat jäljellä ne attribuutit, joita muutos ei koskenut. Uudessa taas AsuntoID, AsukasID ja mahdolliset AsukasID:hen liittyvät riippuvuudet. AsukasID taas on funktionaalisesti riippuvainen AsuntoID:stä, joten siksi vähintään myös AsuntoID:n tuominen tähän uuteen tauluun oli välttämätöntä, joskin tämä nähdään jo ilman riippuvuusarvioitakin.
Seuraavassa vaiheessa arvioidaan kaikkia syntyneitä yksilötyyppejä toisen normaalimuodon suhteen.


16.5 Toinen ja kolmas normaalimuoto
Seuraavissa normaalimuodoissa arvioidaan ominaisuustyyppien eli attribuuttien funktionaalisia riippuvuuksia.
16.5.1 TOINEN NORMAALIMUOTO
Määritelmä:

Yksilötyyppi on toisessa normaalimuodossa, kun se on 1. normaalimuodossa ja sen ei-avain -ominaisuustyypit ovat täydellisesti funktionaalisesti riippuvia sen pääavaimesta.


16.5.2 TÄYDELLINEN FUNKTIONAALINEN RIIPPUVUUS
Funktionaalinen riippuvuus voi kohdistua luonnollisestikin avainominaisuustyyppiin. Jos avain koostuu kahdesta tai useammasta ominaisuustyypistä, eli se on kaksois-, kolmois-, jne. avain, ja jos funktionaalinen riippuvuus ei kohdistu kaikkiin avaimen osiin, ei riippuvuus ole täydellinen. Täydellinen funktionaalinen riippuvuus pääavaimesta tarkoittaa siis, että ominaisuustyyppi on riippuvainen koko pääavaimesta eli kaikista sen attribuuteista.
Tämä selvinnee parhaiten tulevan normalisointiesimerkin myötä. Toisessa normaalimuodossa ei saa esiintyä epätäydellisiä pääavainriippuvuuksia. Jos näin on, toimitaan kuten ensimmäisessäkin vaiheessa: Ongelmakohta eriytetään yksilötyypistä luomalla uusi tai uusia yksilötyyppejä, kunnes kaikki yksilötyypit täyttävät tämän ehdon. Jos ominaisuustyyppi on funktionaalisesti riippuvainen muusta kuin pääavaimesta, ei tällaisia riippuvuuksia tarkastella vielä tässä vaiheessa. Ainoastaan pääavaimiin kohdistuvia riippuvuuksia.


16.5.3 KOLMAS NORMAALIMUOTO
Määritelmä:

Yksilötyyppi on kolmannessa normaalimuodossa, kun se on
2. normaalimuodossa ja sen ei-avain -ominaisuustyypit eivät ole funktionaalisesti riippuvia toisista ei-avain -ominaisuustyypeistä tai niiden joukoista.


16.5.4 MÄÄRITTELYN MERKITYS KÄYTÄNNÖSSÄ
Kolmannen normaalimuodon määritys sanoo, että ei-avain attribuutit (siis tavalliset attribuutit) eivät saa olla funktionaalisesti riippuvia muuta kuin pääavaimesta. Ei siis saa esiintyä riippuvuuksia, jotka eivät kohdistuisi pääavaimeen. Tästäkin nähdään käytännön esimerkki seuraavaksi.
Kun yksilötyyppi on kolmannessa normaalimuodossa, on sen normalisointitarkistus valmis.


16.6 Normalisointiesimerkki
Normalisoimme yksilötyypin kolmanteen normaalimuotoon asti. Normalisoitava kohde on valittu siten, että joudumme puuttumaan sen ominaisuuksiin jo 1. vaiheessa. Näin saada esimerkki kustakin normaalimuodosta ja vaadittavista toimenpiteistä.


16.6.1 NORMALISOITAVA YKSILÖTYYPPI
Alla on normalisoitava yksilötyyppi ominaisuustyyppeineen. Pääavainominaisuustyypit on alleviivattu.


Alla on annettu normalisoitava yksilötyyppi hahmoteltuna tauluna joka sisältää esimerkkiluontoista dataa. Huomaa, että Osoite ei sisällä monikertoja, vaan yksittäisen tekstikentän / merkkijonon. Sijainti sen sijaan sisältää useita sijainti-tyyppisiä sijaintitietoja, ja on siten koostettu. (kts. aiempi esimerkki koostetusta AsukasID:stä ylempää, jos tarpeen). Myös Kokoelma on koostettu.

Valokuva-arkisto

KuvaID	Kokoelma	Nimi	Sijainti	KuvaajaID	Nimi	Osoite	Puhelinnumero
1	Luonto, Linnut	Kaakkurin lento	Albumi A, Tietokanta-1	3	Jukka Niemi	Jupiterinkatu 7A5, 53850, Lappeen...	358 040-512512
2	Maisema, Luonto	Kilpisjärven ranta	Albumi A, Albumi C	5	Terhi Tuomela	Postikatu 5A3, 33100, Tampere	358 050-123123
3	Luonto, Maisema, Eläimet	Lehmät laitumella	Albumi B, Albumi C	2	Juhani Mäki	Hirvitie 10, 12100 Helsinki	368 040-321123
			Tietokanta-1
4	Perhe, Juhla	Joulu Raumalla	Albumi F	5	Terhi Tuomela	Postikatu 5A3, 33100, Tampere	358 050-123123
5	Maisema	Aamunkoitto	Albumi C	10	Samuli Saari	Katajakatu 7, 47100, Kouvola	358 041-654321
6	Matkailu, Nähtävyys, Loma	Branderburgin portti	Albumi J, Tietokanta-2	10	Samuli Saari	Katajakatu 7, 47100, Kouvola	358 041-654321
7	Luonto, Linnut	Pöllö	Albumi B, Tietokanta-1	3	Jukka Niemi	Jupiterinkatu 7A5, 53850, Lappeenra...	358 040-512512
jne...							










16.6.2 YKSILÖTYYPIN KUVAUS
Yksilötyypillä lienee tarkoitus mallintaa valokuva-arkistoa, jossa kuvat on jaoteltu kuuluviksi kokoelmiin (tai aiheisiin, asiasanoihin tms.). Kuvalle on annettu nimi ja kuvasta voi olla kopioita eri paikoissa: Ne nähdään sijainti tiedoista. Sijainti edelleen määräytyy kokoelman ja nimen perusteella: Luontokuvat esimerkiksi on jaettu albumeihin nimen mukaan, koska kaikki eivät mahtuisi yhteen albumiin. Toisaalta, kaikki eläinaiheiset kuvat löytyvät samasta tietokannasta. Tiedetään myös kuka on ollut kuvaaja (ID ja nimi) ja toisaalta kuvaajasta on saatavilla tietoja, kuten osoite ja puhelinnumero.
Kuten yllä taulumuotoisen esityksen yhteydessä on mainittu, esiintyy taulussa monikertoja: Yhtä kenttää kohden on annettu kuvalle useita sijaintitietoja, tai ainakin enemmän kuin yksi. Samoin on annettu useita kokoelmatietoja per kuva. Analogia on sama kuin aiemmassa esimerkissä, jossa asunnossa oli merkitty asuvaksi useita AsukasID:tä.


16.7 Normalisointiesimerkin ensimmäinen vaihe
Havaittiin, että yksilötyypissä esiintyi monikertoja. Ensimmäisen normaalimuodon määrityksen mukaan poistamme nämä ongelmat ja saatamme rakenteen muotoon, jossa monikertoja ei enää esiinny, mutta niin, että tietojen looginen yhteys/eheys ei muutu. Tämä tarkoittaa, että funktionaaliset riippuvuudet on huomioitava.


16.7.1 LÄHTÖTILANNE
Ongelmakohdat on merkitty yksilötyyppiin sinisellä. Olemme myös merkinneet yksilötyypissä vallitsevat funktionaaliset riippuvuudet nuolilla.



Nimi on funktionaalisesti riippuvainen kuvanumerosta. Sijainti on riippuvainen Kokoelmasta ja Nimestä. KuvaajaID on riippuvainen Kuvanumerosta. Kuvaajan nimi, osoite ja puhelinnumero ovat funktionaalisesti riippuvaisia KuvaajaID:stä.

16.7.2 RATKAISU
Irrotetaan ongelmakohdat ja luodaan uusi yksilötyyppi/tyyppejä tarpeen mukaan. Otetaan mukaan ne ominaisuustyypit, joista ongelmakohta on riippuvainen. Otetaan myös näille mukaan otettaville niiden riippuvuudet. Näin varmistuu tietoeheyden säilyminen.
Alla ratkaisu, eli tilanne 1. normaalivaiheen jälkeen:



Nähdään miten irrotetuista Sijainti ja Kokoelma tiedoista muodostui uusi yksilötyyppi. Kokoelma tuli siihen mukaan avaimena -- nyt voi olla yksittäisen kuvan jokaisella kokoelmatiedolla oma sijaintinsa, jos se on tarpeen, ilman monikertoja. Nimen vaatima KuvaNro on myös mukana. Nimi taas on mukana koska Sijainti riippuu osaltaan siitä. Uuden yksilötyypin alapuolella nähdään mitä jäi jäljelle lähtötilanteen yksilötyypistä irrotusoperaation jälkeen. KuvaNro jää sinne, koska KuvaajaID riippuu siitä.
Voidaan edetä seuraavaan vaiheeseen.

16.8 Normalisointiesimerkin toinen vaihe
Toisen normaalimuodon määritelmän mukaisesti tarkastellaan ei-avain ominaisuustyyppejä, jotka ovat riippuvia vain osa-avaimesta. Eli tämän vaiheen jälkeen tuli olla tilanne sellainen, että ei ole muita kuin täydellisiä funktionaalisia riippuvuuksia tapauksissa, joissa riippuvuus kohdistuu pääavaimeen.


16.8.1 LÄHTÖTILANNE
Ongelmakohdat on jälleen merkitty yksilötyyppiin.



Nimi ja Sijainti ovat vain osittain funktionaalisesti riippuvia pääavaimesta, joka on nyt kaksoisavain. Kumpikin riippuu vain avaimen osasta.


16.8.2 RATKAISU
Irrotetaan ongelmakohdat ja luodaan uusia yksilötyyppejä. Edelleen otetaan mukaan ne ominaisuustyypit, joista ongelmakohta on riippuvainen.
Alla ratkaisu, eli tilanne 2. normaalimuotoon saattamisen jälkeen:


Nimi ja Sijainti irrotettiin, ja luotiin uudet yksilötyypit niiden riippuvuuksien perusteella. Nähdään, että kaikki funktionaaliset avainriippuvuudet ovat nyt täydellisiä.
Voidaan edetä kolmanteen vaiheeseen.

16.9 Normalisointiesimerkin kolmas vaihe
Kolmas normaalimuoto keskittyi ei-avain ominaisuustyyppien välisiin riippuvuuksiin. Nyt on jo poistettu monikerrat ja on varmistettu, että avainriippuvuudet ovat täydellisiä. Viimeinen normaalimuoto varmistaa, että kaikki ominaisuustyypit, jotka eivät ole osa avainta, ovat avaimesta riippuvaisia. Ts. ei-avainominaisuustyypit eivät saa olla funktionaalisesti riippuvia muista kuin avainominaisuustyypeistä.


16.9.1 LÄHTÖTILANNE
Ongelmakohdat on jälleen merkitty yksilötyyppiin. Havaittiin, että KuvaajaID riippuu ihan oikein yksilötyypin pääavaimesta, mutta muut ominaisuustyypit samaisessa yksilötyypissä riippuvatkin KuvaajaID:stä, joka ei ole avain. Siihen on siis puututtava. Korjataan tilanne niin, että luodaan tästä ei-avain ominaisuustyypistä avainominaisuustyyppi: Tällöin ei enää ole riippuvuuksia ei-avaimiin. Kuten aiemminkin, on ongelmakohta irrotettava, jotta tämä voisi toteutua.





16.9.2 RATKAISU

Ratkaisu oli varsin suoraviivainen kolmannen vaiheen suhteen. KuvaajaID:stä tuli luontevasti oman yksilötyyppinsä pääavain, ja nyt siitä riippuneet ominaisuustyypit riippuvat pääavaimesta.

Todetaan, että yksilötyypit ovat 3. normaalimuodossa. Normalisointi on valmis. Voidaan vielä havainnollistaa yksilötyyppien väliset suhteet:

Verrattaessa lähtötilanteeseen -- yksi yksilötyyppi, joka sisälsi kaikki tietokannan ominaisuustyypit -- on saavuttu nyt rakenteeseen, joka on sellaisenaan muutettavissa relaatiotietokannaksi. Eri asia on, kuinka helppo tällainen lähestymistapa on. Käsitemallin laatiminen on varmasti intuitiivisempaa monenlaisten tietokantojen kohdalla.
Mutta kuten alussa totesimme, tuntemalla normalisoinnin vaiheet voimme suorittaa normalisointitarkistuksen jokaiselle käsitemallin yksilötyypille ja näin varmistua siitä, että ne ovat normalisoituja. Tällöin pitää todeta, että yksilötyyppi on kolmannessa normaalimuodossa. Jos näin on, hyväksymme sen. Jos ei, suoritamme sille normalisoinnin kuten tässä. Lopulta tuloksena on tieto siitä, että malli varmasti on normalisoitu.

17.1-17.3 Hyödyllisiä lisätyökaluja kyselyihin ja rakennemäärityksiin
71. Luvun sisällöstä
72. Lisätyökaluja WHERE ehtojen laatimiseen
73. SQL-kielisiä eheysmääritteitä

17.1 Luvun sisällöstä
Tähän kurssin viimeiseen teorialukuun on koottu joitain SQL-kielen ominaisuuksia, joita ei ole käsitelty aiemmin, mutta joiden tuntemisesta voi olla hyötyä. Aluksi annetaan lisätyökaluja kyselyjen muodostamiseen. Menetelmistä on hyötyä myös muissa yhteyksissä, joissa WHERE ehtoja voidaan käyttää (esim UPDATE, DELETE komennot.) Lopuksi katsotaan vielä kuinka yksinkertaisia eheyssääntöjä (kts. luku 9) voidaan määrittää SQL-kielellä.
 

17.2 Lisätyökaluja WHERE ehtojen laatimiseen
 

17.2.1 BETWEEN-AND
Olemme käyttäneet mm. SELECT-kyselyiden WHERE-ehdoissa AND ja OR -sanojen yhdistelmiä muodostamaan ehtoja, jotka määrittävät arvoalueita. Esimerkiksi alla olevan kaltainen vuosiluvuista muodostuva arvoväli voitiin muodostaa AND-sanalla:

Esimerkki:
	Haetaan albumit, jotka on julkaistu vuosien 1980 ja 2002 välillä. Asetetaan kaksi ehtoa: Jälkeen tai tasan 1980, sekä ennen tai tasan 2002. Ehdot sidotaan AND-operaattorilla, ja nyt molempien on oltava tosia.
	SELECT * FROM Albumi
	   WHERE Julkaistu >= 1980 AND Julkaistu <= 2002;
 
Tulos:
AlbumiID  |       Nimi        |   Esittaja    | Julkaistu | Kesto
----------+-------------------+---------------+-----------+-------
        6 | Valkoinen kupla   | Eppu Normaali |      1986 |
        1 | Come Away With Me | Norah Jones   |      2002 |    45
        3 | Talkie Walkie     | Air           |      2002 |    43
        5 | Mutter            | Rammstein     |      2001 |    45
        7 | Aura              | CMX           |      1994 |    56
        9 | Vainajala         | CMX           |      1998 |    48
(6 rows)
 
Sama määrittely voidaan muodostaa myös erityisellä BETWEEN - AND sanayhdistelmällä. Se käy kaikkiin arvojoukkomäärityksiin, mutta on helpompi kirjoittaa ja voi auttaa yksinkertaistamaan monimutkaisten WHERE ehtojen luettavuutta.
Määritteen syntaksi on seuraava: [attribuutti] BETWEEN [alin arvo] AND [ylin arvo]
Esimerkki:
	Käytetään BETWEEN-AND sanaparia muodostamaan arvojoukko. Julkaisuvuosi asetetaan olemaan suurempi tai yhtä suuri kuin 1980 ja pienempi tai yhtäsuuri kuin 2002.
	SELECT * FROM Albumi
	   WHERE Julkaistu BETWEEN 1980 AND 2002;
 
Tulos:
AlbumiID  |       Nimi        |   Esittaja    | Julkaistu | Kesto
----------+-------------------+---------------+-----------+-------
        6 | Valkoinen kupla   | Eppu Normaali |      1986 |
        1 | Come Away With Me | Norah Jones   |      2002 |    45
        3 | Talkie Walkie     | Air           |      2002 |    43
        5 | Mutter            | Rammstein     |      2001 |    45
        7 | Aura              | CMX           |      1994 |    56
        9 | Vainajala         | CMX           |      1998 |    48
(6 rows)
 

17.2.2 IN
WHERE ehdoissa on tähän asti käytetty seuraavanlaista määrittelyä kun on ollut tarpeen kohdistaa attribuuttiin useita mahdollisia OR-muotoisia ehtoja: WHERE "Julkaistu" = 1980 OR "Julkaistu" = 1985 OR "Julkaistu" = 1990. Käyttämällä erityistä IN sanaa voidaan laatia attribuuttikohtaisesti lista ehdoista, jotka noudattavat edellä olevan kaltaista OR ketjua, mutta siten että ehto on paljon helpompi kirjoittaa eikä vie tilaa yhtä paljoa.
Määritteen syntaksi on seuraava: [attribuutti] IN ([arvo1], [arvo2] ...)

Esimerkki:
	Haetaan albumit, joissa esittäjänä on joko The Beatles, Eppu Normaali tai Norah Jones. Käytetään OR sanoista muodostuvan "attribuutti = ehto" ketjun sijaan IN sanaa.
	SELECT * FROM Albumi
	   WHERE Esittaja IN ('The Beatles', 'Eppu Normaali', 'Norah Jones');
 
Tulos:
AlbumiID  |       Nimi        |   Esittaja    | Julkaistu | Kesto
----------+-------------------+---------------+-----------+-------
        6 | Valkoinen kupla   | Eppu Normaali |      1986 |
        1 | Come Away With Me | Norah Jones   |      2002 |    45
       10 | The Beatles       | The Beatles   |      1968 |    93
       11 | Abbey Road        | The Beatles   |      1969 |    47
       12 | Rubber Soul       | The Beatles   |      1965 |    36
       13 | Revolver          | The Beatles   |      1966 |    35
(6 rows)
 

17.2.3 LIKE
LIKE-operaattoria käytetään muodostettaessa WHERE ehtoja, joihin sisältyy merkkijonoon liittyvä ilmaisu. Tällaisia ehtoja tarvitaan, kun haetaan esimerkiksi tietyllä kirjaimella alkavia nimiä, tai tietyn merkkijonon sisältäviä arvoja. LIKE-operaattorin yhteydessä käytetään merkkiä % (prosentti-merkki) symboloimaan sellaisia merkkejä, jotka voivat saada minkä arvon hyvänsä. Yhdistelemällä merkkejä ja % symboleja voidaan luoda monipuolisia merkkijono-ehtoja. Alla olevat esimerkit selventävät parhaiten LIKE-operaattorin käyttöä.

Esimerkki:
	Haetaan kaikki albumit, joiden nimi (=merkkijono) alkaa kirjaimella 'T'. Käytetään ehdon muodostamiseen LIKE-operaattoria, ja annetaan ehtomerkkijonoksi 'T%', joka voidaan lukea: "Merkkijonon ensimmäisen kirjaimen on oltava T, ja loput merkit voivat olla mitä vain".
	SELECT * FROM Albumi
	   WHERE Nimi LIKE 'T%';
 
Tulos:
  AlbumiID |           Nimi            |  Esittaja   | Julkaistu | Kesto
----------+---------------------------+-------------+-----------+-------
        2 | The Dark Side of the Moon | Pink Floyd  |      1973 |    43
        3 | Talkie Walkie             | Air         |      2002 |    43
       10 | The Beatles               | The Beatles |      1968 |    93
(3 rows)
 
Esimerkki:
	Haetaan kaikki albumit, joiden nimi alkaa kirjaimin 'Th'.
	SELECT * FROM Albumi
	   WHERE Nimi LIKE 'Th%';
 
Tulos:
  AlbumiID |           Nimi            |  Esittaja   | Julkaistu | Kesto
----------+---------------------------+-------------+-----------+-------
        2 | The Dark Side of the Moon | Pink Floyd  |      1973 |    43
       10 | The Beatles               | The Beatles |      1968 |    93
(2 rows)
 
Prosenttimerkki voidaan sijoittaa mielivaltaisesti suhteessa vaadittaviin merkkeihin. Prosenttimerkkejä voi myös olla useita.

Esimerkki:
	Haetaan kaikki albumit, joiden nimessä esiintyy merkki 'R'. Muodostetaan ehdoksi '%R%', mikä voidaan lukea: "Sisältää mitä vain merkkejä sekä sisältää perään merkkijonon 'R', ja sisältää taas mitä vain merkkejä. % tarkoittaa myös, että merkkejä ei tarvitse esiintyä lainkaan.
	SELECT * FROM Albumi
	   WHERE Nimi LIKE '%R%';
 
Tulos:
AlbumiID  |    Nimi     |  Esittaja   | Julkaistu | Kesto
----------+-------------+-------------+-----------+-------
       11 | Abbey Road  | The Beatles |      1969 |    47
       12 | Rubber Soul | The Beatles |      1965 |    36
       13 | Revolver    | The Beatles |      1966 |    35
(3 rows)

Nähdään, että kussakin nimessä on merkkijono 'R'.
 
%-merkin käytöstä:
 
	'%teksti' = Merkkijonon on päätyttävä merkkeihin "teksti"
	
	'teksti%' = Merkkijonon on alettava merkeillä "teksti".
	
	'%teksti%' = Merkkijonon seasta tai alusta tai lopusta on löydyttävä merkit "teksti"
	
	'%A%B' = Merkkijonon alku on mielivaltainen; sen jälkeen on löydyttävä merkki A, jota voi seurata mielivaltainen merkkijono, ja viimeisenä merkkinä on oltava B, jota ei saa seurata enää muita merkkejä. Tämän ehdon täyttävät molemmat seuraavat merkkijonot: "AB" ja "xyAAAzB". Merkkijono "xyABa" ei täytä ehtoa, sillä B:tä seuraa merkki.
 
Prosenttimerkin ohessa LIKE-operaattori tunnistaa myös '_' merkin. Siinä missä % tarkoittaa mielivaltaista merkkijonoa, tarkoittaa _ mielivaltaista yksittäistä merkkiä. Lisäksi '_' tarkoittaa, että jokin merkki on oltava olemassa tällä paikalla.
_-merkin käytöstä:
 
	'_teksti' = Merkkijonon on päätyttävä merkkeihin "teksti" ja sen on alettava yhdellä merkillä, joka saa lisäksi olla mikä vain. Näin ollen "Ateksti" kelpaa, mutta "ABteksti" ei.
Esimerkki: Listaa sellaisten albumien nimet, joiden nimen toinen merkki on 'a', ja jotka päättyvät merkkiin 'e'.
SELECT Nimi FROM Albumi
   WHERE Nimi LIKE '_a%e';
 
Tulos:
     Nimi
---------------
 Talkie Walkie
(1 row)
 

17.2.4 NOT, IS NOT NULL JA IS NULL
NOT operaattorilla voidaan WHERE ehto kääntää päinvastaiseksi: Voidaan kertoa, että kyselyn toteuttavat arvot eivät saa olla tämän ehdon täyttäviä. IS NULL ja IS NOT NULL avulla voidaan asettaa ehto, että arvon on oltava NULL, tai että se ei saa olla NULL.

Esimerkki:
	Haetaan albumit, joiden esittäjänä ei ole The Beatles eikä Norah Jones.
	SELECT * FROM Albumi
	   WHERE NOT Esittaja = 'The Beatles' AND NOT "Esittaja" = 'Norah Jones';
 
Tulos:
AlbumiID  |           Nimi            |   Esittaja    | Julkaistu | Kesto
----------+---------------------------+---------------+-----------+-------
        6 | Valkoinen kupla           | Eppu Normaali |      1986 |
        2 | The Dark Side of the Moon | Pink Floyd    |      1973 |    43
        3 | Talkie Walkie             | Air           |      2002 |    43
        5 | Mutter                    | Rammstein     |      2001 |    45
        4 | Playing the Angel         | Depeche Mode  |      2005 |    52
        7 | Aura                      | CMX           |      1994 |    56
        8 | Animals                   | Pink Floyd    |      1977 |    41
        9 | Vainajala                 | CMX           |      1998 |    48
(8 rows)
 
Esimerkki:
	Haetaan lainaajat, joilla sähköpostiksi oli asetettu NULL-arvo.
	SELECT * FROM Lainaaja
	   WHERE Email IS NULL;
 
Tulos:
LainaajaID  | Etunimi |  Sukunimi   |   PuhNro    | Email
------------+---------+-------------+-------------+-------
          2 | Satu    | Tahvanainen | 0412211331  |
          6 | Liisa   | Lahtela     | 051-4455222 |
(2 rows)
 

17.3 SQL-kielisiä eheysmääritteitä
Olemme kurssilla aiemmin käsitelleet eheyssääntöjä niin suunnittelun kuin relaatiomallinkin yhteydessä. SQL-kieli tarjoaa mahdollisuuksia määrittää yksinkertaisia, taulukohtaisia eheyssääntöjä varsin vaivattomasti. Tällaisia ovat esimerkiksi kaksoisarvojen kieltäminen muiltakin kuin avainattribuuteilta, sekä attribuuttikohtaiset, WHERE ehtojen kaltaiset määritteet attribuutin hyväksymille arvolle. Myös pääavain-vierasavain yhteydelle voidaan asettaa standardista poikkeavia, höllentäviä tai edelleen normaalia rajoittavampia sääntöjä, jotka liittyvät avainyhteyksissä läsnä olevien arvojen poistoihin ja päivityksiin. Emme kuitenkaan mene näin pitkälle tämän kurssin puitteissa, vaan katsomme, millaisia eheyssääntöjä voidaan perusattribuuteille asettaa UNIQUE ja CHECK avainsanoilla.
 

17.3.1 UNIQUE MÄÄRITE JA DEFAULT LISÄMÄÄRITTEET
Tunnemme ennestään seuraavat määritteet, jotka voidaan antaa attribuutille esimerkiksi CREATE TABLE tai ALTER TABLE komentojen yhteydessä.
 
MÄÄRITE	SELITE
PRIMARY KEY	Pääavain
FOREIGN KEY	Vierasavain
DEFAULT	Oletusarvo
NOT NULL	Arvo pakollinen
 
Esittelemme uuden määritteen, UNIQUE. Jos attribuutille annetaan määrite UNIQUE, tarkoittaa se, että attribuutin jokaisella tietueella on oltava yksilöllinen arvo. Jos annetaan attribuutille Tuotekoodi määrite UNIQUE, ei kahdella tietueella voi olla samaa Tuotekoodi arvoa ja yritettäessä syöttää tällainen saadaan virheilmoitus samoin kuin jos yksittäisestä attribuutista koostuvalle pääavaimelle koitettaisiin antaa jo entuudestaan esiintyvä pääavainarvo.
DEFAULT määritettä on tähän saakka käytetty sellaisenaan asettamaan attribuutille oletusarvo, jonka se saa, mikäli sille ei syötetä minkäänlaista arvoa. DEFAULTin yhteydessä voidaan tätä oletusarvoa tarkentaa tietyillä yksinkertaisilla määritteillä. Näistä peruskäytön kannalta kiinnostavia ovat:
 
DEFAULT MÄÄRITE	VAIKUTUS ATTRIBUUTTIIN
USER	Palauttaa arvoksi TKHJ:n sillä hetkellä tunteman käyttäjänimen. Määritteestä on myös tarkennuksia, esim SESSION_USER tai SYSTEM_USER.
CURRENT_DATE	Palauttaa arvoksi järjestelmän sen hetkisen SQL DATE tietotyypin mukaisen päivämäärän.
CURRENT_TIME	Kuten CURRENT_DATE, mutta palauttaa TIME tietotyyppiä olevan ajan.
CURRENT_TIMESTAMP	Kuten CURRENT_TIME, mutta palauttaa TIMESTAMP tyyppisen ajan. (kts. liite SQL tietotyypit.)
 
Esimerkki:
	Luodaan taulu Tuote. Määritetään, että Tuotenimi on oltava aina yksilöllinen. Tuotetietojen viimeisin päivitys saa oletusarvoksi tuotetiedon lisäysajankohdan.
	CREATE TABLE Tuote (
	   Tuotekoodi  INTEGER PRIMARY KEY,
	   Nimi        VARCHAR(30) NOT NULL UNIQUE,
	   Hinta       DECIMAL NOT NULL,
	   Paivitetty  DATE NOT NULL DEFAULT CURRENT_DATE
	);
 
Tulos:
Mikäli attribuutille Paivitetty ei anneta arvoa, saa se senhetkisen päivämäärän.  Kahta samaa Nimi arvoa ei voida syöttää.
 

17.3.2 CHECK TARKISTUKSET ATTRIBUUTTIEN ARVOILLE
CHECK-lauseella voidaan muodostaa sekä yksinkertaisia että monimutkaisempiakin sääntöjä, jotka liittyvät yhteen tai useampaan attribuuttiin samanaikaisesti. CHECK-lauseen määrittävä tarkiste voi sisältää jopa kokonaisia SELECT kyselyjä, mutta perustarpeisiin riittävät usein WHERE ehdon kaltaiset ja laajuiset lauseet jotka määrittävät esimerkiksi laillisten arvojen ylä- ja alarajat tai joukon laillisia arvoja OR muodossa.
Kuten esimerkiksi REFERENCES  tai PRIMARY KEY määritteet, voidaan CHECK lauseetkin sijoittaa joko attribuutin määrittelyn yhteyteen, eli rivin loppuun, tai niiden jälkeen. Käytetään esimerkkiä selventämään CHECK-lauseen käyttöä.
 
Esimerkki:
	Luodaan samankaltainen taulu Tuote kuin ylempänä, mutta asetetaan määritteitä attribuuttien arvoille CHECK-lauseilla.
	CREATE TABLE Tuote (
	   TuoteID INTEGER PRIMARY KEY,
	   Nimi  VARCHAR(30) NOT NULL UNIQUE,
	   Koodi VARCHAR(5) NOT NULL UNIQUE,
	   Hinta INTEGER NOT NULL,
	   Paivitetty DATE NOT NULL DEFAULT CURRENT_DATE,
	  
	   CHECK (Koodi NOT LIKE 'A%A' AND Koodi NOT LIKE 'B%'),
	   CHECK (Hinta > 0),
	   CHECK (TuoteID BETWEEN 1 AND 10000 AND TuoteID % 2 = 0) 
	);
 
Tulos:
Pääavain TuoteID:n arvojen on oltava väliltä 1 ja 10 000, ja TuoteID:n on oltava aina parillinen luku. (Tarkistetaan laskemalla osamäärä kahdella jakaen.)

Hinnan on aina oltava suurempi kuin nolla.

Koodi attribuutin merkkijo (lyhenne tms.) ei saa olla asetettujen LIKE-määritteiden mukainen. Eli jos Koodi alkaa merkillä 'A', se ei saa päättyä merkkiin 'A'; se ei myöskään saa alkaa merkillä 'B'.
 
Tulos: Katsotaan vielä, mitä tapahtuu, jos asetettujen eheysvaatimusten vastaisia arvoja koitetaan syöttää.
insert into Tuote values (111, 'Tuote', 'ABBA', -10);
ERROR:  new row for relation "Tuote" violates check constraint "Tuote_TuoteID_check"

insert into Tuote values (110, 'Tuote', 'ABBA', -10);
ERROR:  new row for relation "Tuote" violates check constraint "Tuote_Hinta_check"

insert into Tuote values (110, 'Tuote', 'ABBA', 10);
ERROR:  new row for relation "Tuote" violates check constraint "Tuote_Koodi_check"

insert into Tuote values (110, 'Tuote', 'ABC', 10);
INSERT 0 1


SELECT * FROM Tuote;

 TuoteID | Nimi  | Koodi | Hinta | Paivitetty
---------+-------+-------+-------+------------
     110 | Tuote | ABC   |    10 | 2007-10-22
(1 row)


18. SQL-injection
18. SQL-injection
 
18.1 SQL-INJECTION, MISTÄ KYSE?
SQL-injektio on yksi vakavimmista web-sovellusten haavoittuvuuksista. SQL- injektiossa hyökkääjä välittää SQL-lauseen mukana tietoa, jonka sovellus tulkitsee osaksi SQL-lausetta ja ajaa lauseen, jos se on ajokelpoinen. Tämä pahimmassa tapauksessa avaa hyökkääjälle pääsyn jopa koko sovelluksen tietokantaan, mikä mahdollistaa esimerkiksi identiteettivarkaudet ja/tai muut petokset sekä haitanteon.
Oletetaan tilanne, jossa sovellus pyytää käyttäjältä käyttäjätunnuksen ja salasanan alla olevan lomakkeen kaltaisella lomakkeella.
 

 
Käyttäjän syötettyä tietonsa ohjelma etsii oikeaa käyttäjää vertaillen sähköpostiosoitetta sekä salasanaa tietokannan riveihin esim. seuraavasti:
SELECT * FROM Users WHERE Email = ‘$email’ AND Password = ‘$password’
Vastine löytyy, jos WHERE-ehdon paluuarvo on tosi (eli käyttäjätunnus ja salasana vastaavat tietokannassa olevaa käyttäjää) ja näin käyttäjä saa pääsyn sovellukseen ja sisäänkirjautuminen tapahtuu. Jos sovelluksen ohjelmistokehittäjä  ei ole tehnyt käyttäjän syötetarkasteluja, voi hyökkääjä pyrkiä syöttämään tekstikenttiin erikoismerkkejä ja saada aikaan kirjautumistietojen virheellisen käyttötilanteen esim. siten, että emailin ja salasanan antamisen sijaan kirjautumista yrittävä henkilö antaa login-lomakkeen kenttiin tiedon 1’ or ’1’ = ’1, joka sijoittuu SELECT-lauseeseen seuraavasti:
SELECT * FROM Users WHERE Email = ‘1’ OR ‘1’ = ‘1’ AND Password = ‘1’ OR ‘1’ = ‘1’
Molemmat vertailut ovat käytännössä tosia, joten kysely palauttaa arvon ja hyökkääjä saa tuloksena pahimmassa tapauksessa arkaluontoista dataa. Riippuen tietokannasta palauttaa SQL-lause yhden arvon tai useampia. Lisäksi SELECT-lauseeseen olisi mahdollista liittää UNIONILLA toinen lause vaikkapa taulun poistava DROP -lause, tässä tilanteessa hyökkääjän olisi kuitenkin tiedettävä tietokannan rakenteesta (taulujen nimet) etukäteen, jotta osaisi näin toimia.
 
18.2 SQL-INJECTIONILTA SUOJAUTUMINEN
 
Varmin keino suojautua SQL-injektionilta on rakentaa sovellus siten, että käyttäjän antamaa syötettä ei sellaisenaan toimiteta tietokantaan vaan aina tehdään ohjelmallisesti tarkistukset sille, että SQL-lauseen mukana ei pääse ylimääräisiä komentoja/toimintoja.
SQL-kysely voi olla dynaaminen tai parametroisoitu. Dynaamisessa kyselyssä käyttäjän syötteet välittyvät suoraan tietokantaan. Tässä tapauksessa kysely hyväksyy syötteen sellaisenaa, oli se haitallinen tai ei. Parametrisoitu kysely on näin ollen parempi vaihtoehto. Käyttäjän syöte talletetaan parametreihin ja parametrien sisältö tarkistetaan ohjelmallisestin ennen syötteen liittämistä SQL-kyselyyn ja kyselyn välittämistä tietokantaan.
Tietoturvan näkökulmasta sovelluksen käyttäjien salasanat ovat usein kriittisin osa. Tästä syystä tapana ei ole tallettaa salasanoja salaamattomana, tällöin vaikka hyökkääjä saisi salasanat selville SQL-injection avulla selville, niitä ei pysty hyödyntämään ilman tietoa salausavaimesta.
 
 

